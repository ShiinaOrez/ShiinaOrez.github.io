
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

  <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget/autoload.js"></script>

  
    <title>《Concurrency in Go》阅读笔记 -- 第三章：Go语言并发组件 | Shiina Orez</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Shiina Orez">
    
    <meta name="description" content="《Concurrency in Go》

本章节从goroutine入手，讲解go语言的各种并发原语。在讲解完goroutine之后，对于传统的内存同步访问的并发原语：sync包中的Mutex，RWMutex，Cond，Once，WaitGroup，Pool等进行了分析。在此之后着重讲了go语言的另">
    
    
    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="shiina_orez">
    <meta name="twitter:title" content="《Concurrency in Go》阅读笔记 -- 第三章：Go语言并发组件 | Shiina Orez">
      
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>
</html>
  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/gopher.png" alt="Shiina Orez" title="Shiina Orez"></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Shiina Orez">Shiina Orez</a></h1>
				<h2 class="blog-motto">Backend coder, coding every day.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/tags">Tags</a></li>
					
						<li><a href="/categories">Categories</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search">
						<input type="hidden" name="q" value="site:shiinaorez.github.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/06/14/concurrency-in-go-3/" title="《Concurrency in Go》阅读笔记 -- 第三章：Go语言并发组件" itemprop="url">《Concurrency in Go》阅读笔记 -- 第三章：Go语言并发组件</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://shiinaorez.github.com" title="Shiina Orez">Shiina Orez</a>
    </p>
  <p class="article-time">
    <time datetime="2019-06-13T19:27:06.000Z" itemprop="datePublished">2019-06-14</time>
    Updated:<time datetime="2019-06-13T19:38:41.007Z" itemprop="dateModified">2019-06-14</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#《Concurrency-in-Go》"><span class="toc-number">1.</span> <span class="toc-text">《Concurrency in Go》</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3：Go’s-Concurrency-Building-Blocks-Go-语言并发组件"><span class="toc-number">1.1.</span> <span class="toc-text">Chapter 3：Go’s Concurrency Building Blocks Go 语言并发组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine"><span class="toc-number">1.1.1.</span> <span class="toc-text">goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是goroutine？"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">什么是goroutine？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine的独到之处（和普通协程的区别）"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">goroutine的独到之处（和普通协程的区别）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine怎么实现并发"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">goroutine怎么实现并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine中闭包运行的情况"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">goroutine中闭包运行的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine有多么的轻量级"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">goroutine有多么的轻量级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Package-sync"><span class="toc-number">1.1.2.</span> <span class="toc-text">Package sync</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitGroup"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutex-amp-RWMutex"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Mutex &amp; RWMutex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mutex-互斥锁"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">Mutex 互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RWMutex-读写互斥锁"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">RWMutex 读写互斥锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cond-条件变量"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">cond 条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#发送信号的方式：Signal和Broadcast"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">发送信号的方式：Signal和Broadcast</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#once"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">once</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pool-池"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">Pool 池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么使用Pool？"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text">为什么使用Pool？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-信道"><span class="toc-number">1.1.3.</span> <span class="toc-text">channel 信道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建和使用channel"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">创建和使用channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带缓冲的信道-buffered-channel"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">带缓冲的信道 buffered channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel上的操作和相应的结果"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">channel上的操作和相应的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用channel的基本素养"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">使用channel的基本素养</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select语句"><span class="toc-number">1.1.4.</span> <span class="toc-text">select语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为select语句设置超时时间"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">为select语句设置超时时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select语句中的default"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">select语句中的default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用for-select结构在等待同时工作"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">使用for-select结构在等待同时工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#永远阻塞的语句也永远最简单"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">永远阻塞的语句也永远最简单</span></a></li></ol></li></ol></li></ol></li></ol>
		</div>
		
		<h1 id="《Concurrency-in-Go》"><a href="#《Concurrency-in-Go》" class="headerlink" title="《Concurrency in Go》"></a>《Concurrency in Go》</h1><hr>
<blockquote>
<p>本章节从goroutine入手，讲解go语言的各种并发原语。在讲解完goroutine之后，对于传统的内存同步访问的并发原语：sync包中的Mutex，RWMutex，Cond，Once，WaitGroup，Pool等进行了分析。在此之后着重讲了go语言的另一大特色：channel。在最后，讲解了如何结合channel的语法：select语句。</p>
</blockquote>
<blockquote>
<p>插一句题外话：这本书的中文版本的翻译就是一坨屎。</p>
</blockquote>
<hr>
<h2 id="Chapter-3：Go’s-Concurrency-Building-Blocks-Go-语言并发组件"><a href="#Chapter-3：Go’s-Concurrency-Building-Blocks-Go-语言并发组件" class="headerlink" title="Chapter 3：Go’s Concurrency Building Blocks Go 语言并发组件"></a>Chapter 3：Go’s Concurrency Building Blocks Go 语言并发组件</h2><hr>
<h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>goroutine是Golang中最基本的组织单位之一，每个go语言的程序都至少有一个goroutine：main goroutine，它在进程开始时自动创建并且启动。</p>
<h4 id="什么是goroutine？"><a href="#什么是goroutine？" class="headerlink" title="什么是goroutine？"></a>什么是goroutine？</h4><p>简单的说：goroutine是一个并发的函数，可以和别的代码块同时运行（不一定是并行的）。</p>
<p>至于如何使用<code>go</code>关键字来简单的创建一个goroutine，就不多讲了，看到这个博客的人估计没那么傻。</p>
<p>golang中的goroutine是这个世界上独一无二的东西。它不是OS线程，也不是绿色线程（由语言运行时管理的线程）。有些中文的翻译为轻量线程，但是事实上<code>goroutine is a coroutine</code>，也就是说goroutine是一个协程。协程是一种非抢占式的特殊线程（进程和线程是抢占式的）。协程不能被中断，但是协程尤多个允许暂停和重新进入的点。</p>
<h4 id="goroutine的独到之处（和普通协程的区别）"><a href="#goroutine的独到之处（和普通协程的区别）" class="headerlink" title="goroutine的独到之处（和普通协程的区别）"></a>goroutine的独到之处（和普通协程的区别）</h4><p>goroutine的独到之处在于它们与<strong>golang的运行环境</strong>的深度集成。（原文是：<strong>What makes goroutines unique to Go are their deep integration with Go’s runtime.</strong> 这里的所谓<code>golang的运行环境其实是特指的golang的runtime</code> | 在中文翻译中为：它们与Go语言运行时的深度集成，这根本就不通顺嘛！）</p>
<p>goroutine定义了自己的暂停的方法和再切入的点。Go语言的runtime会观察goroutine的运行时的行为，并且在阻塞的时候自动挂起它们，然后在不被阻塞的时候再恢复。 <strong>在golang的runtime和goroutine的逻辑之间有一种优雅的伙伴一样的关系。</strong></p>
<h4 id="goroutine怎么实现并发"><a href="#goroutine怎么实现并发" class="headerlink" title="goroutine怎么实现并发"></a>goroutine怎么实现并发</h4><p>协程（coroutine）和goroutine都是隐式并发结构，这说明并发并不是协程的属性：必须同时托管多个协程，并且给每个协程一个执行的机会。</p>
<p>Golang的主机托管机制是一个M：N调度器，主要机制就是将M个由程序管理的线程映射到N个OS线程。而M：N调度器可以单独写一个博客了，这里就不再细说。</p>
<p>Golang遵循一个称为<code>fork-join</code>的并发模型。</p>
<ul>
<li>fork是指在程序运行中的任意一点，它可以将执行的子分支和父节点同时运行。</li>
<li>join这个词是指的是在将来的某个时候，这个并发的执行分支将会合并在一起。</li>
</ul>
<p><img src="https://i.loli.net/2019/06/11/5cff86dd04d0395892.png" alt></p>
<p>在fork-join模型中，掌握join的点是至关重要的，因为join点是保证程序的正确性和<strong>消除竞争条件</strong>的关键。而控制join点的关键技术是WaitGroup。</p>
<h4 id="goroutine中闭包运行的情况"><a href="#goroutine中闭包运行的情况" class="headerlink" title="goroutine中闭包运行的情况"></a>goroutine中闭包运行的情况</h4><p>我们在快速创建goroutine的时候往往会选择使用匿名函数来创建，这就牵扯到了闭包中变量的引用问题：<strong>闭包可以从创建它们的作用域中获取变量，那么当这个闭包运行的时候，调用这些变量的方式是副本还是引用呢？</strong></p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">salutation := <span class="string">"hello"</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    salution = <span class="string">"welcome"</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"Out:"</span>, salutation)</span><br></pre></td></tr></table></figure>
<p>我的得到的输出是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: welcome</span><br></pre></td></tr></table></figure></p>
<p>事实证明，goroutine在它们所创建的相同地址空间内执行。<br>从另一个角度再进行一个实验：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>&#125; &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(salutation)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>这个程序我们期望得到的结果是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">greetings</span><br><span class="line">good day</span><br></pre></td></tr></table></figure>
<p>以上的所有可能的排列组合，因为我们都知道并发所带来的竞争条件产生的影响，但是输出却让我们大吃一惊：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">good day</span><br><span class="line">good day</span><br></pre></td></tr></table></figure>
<p>当大家看到输出的时候应该已经明白了究竟是怎么回事：<strong>在输出之前，salutation就已经完成了迭代。</strong>    </p>
<p>但是值得注意的一点是，既然迭代已经结束，为什么还能使用salutation的引用呢？这个就和golang的GC有关，golang的GC会小心的把salutation的引用从内存转移到堆，以便能够继续使用。</p>
<p>所以正确的程序应该这样编写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>&#125; &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(salutation <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(salutation)</span><br><span class="line">    &#125;(saluation)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>也就是传入数据的副本。</p>
<p>由于所有的goroutine都在相同的地址空间中运行，而且只有简单的宿主函数，所有使用goroutine编写并发的任务是非常的自然的，golang的编译器很好的处理了内存中的变量，这样goroutine就不会意外的访问被释放的内存，这使得开发人员可以专注于它们的问题是如何被解决的，而不需要去消耗更多精力来管理内存。</p>
<p>但是golang带来的这些好处也付出了一些代价，由于多个goroutine运行在同一个地址空间，所以我们仍然需要担心同步问题。解决问题的方法：sync包和channel我们会在后面的小节进行讨论。</p>
<h4 id="goroutine有多么的轻量级"><a href="#goroutine有多么的轻量级" class="headerlink" title="goroutine有多么的轻量级"></a>goroutine有多么的轻量级</h4><p>以下是摘自Go Programming Language FAQ中的一段话。<br><img src="https://i.loli.net/2019/06/11/5cffa2e8adeaa61523.png" alt="在这里插入图片描述"><br>这段话很夸张的说出：<strong>在同一个地址空间中创建成千上万的goroutine是可行的。</strong></p>
<p>这是吹牛逼吧！怎么可能！</p>
<p>但是goroutine就是这么轻量，一个goroutine只有几千个字节，这完全是ok的。</p>
<p>但是当进程多了起来，一个问题将明显的影响着程序的性能：<strong>上下文之间的切换</strong>。当进程之间来回不断的切换的时候，保存现场和恢复现场的工作显得格外耗时，那么goroutine这么多，在它们之间的切换应该也相当耗时吧？</p>
<p>但是并不！goroutine之间的切换速度是OS线程切换速度的8%！</p>
<p>太轻了，实在是太轻了。goroutine的使用代价如此的小让我们能够放手的去用goroutine解决并发问题。</p>
<hr>
<h3 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package <code>sync</code></h3><blockquote>
<p>sync包包含了对于低级别内存访问同步最有用的并发原语。很简单，很基础。</p>
</blockquote>
<h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>当你不关心并发操作的结果，或者你又其他的方法能够收集它们的结果的时候。WaitGroup是等待一组并发操作完成的好办法。</p>
<p>你可以将WaitGroup视为一个并发安全的计数器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">// <span class="title">Add</span> 方法增加计数器的增量。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// 调用<span class="title">Done</span>方法来对计数器进行递减。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// <span class="title">Wait</span>方法会阻塞，直至计数器为0.</span></span><br></pre></td></tr></table></figure>
<p>使用WaitGroup的时候需要注意的是：Add方法的调用应该是在跟踪的goroutine之外调用的。如以下程序为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的示例</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// wg.Add(1) 如果在这里调用wg.Add()会让程序直接结束。因为竞争条件。</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<h4 id="Mutex-amp-RWMutex"><a href="#Mutex-amp-RWMutex" class="headerlink" title="Mutex &amp; RWMutex"></a>Mutex &amp; RWMutex</h4><p>锁，这一节讲的就是锁。不管是在数据库中还是在一些传统的并发处理中，锁往往都是我们最常见的方式或者方法。而在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Locker</span><br><span class="line">`sync`包中有一个锁接口，具体定义如下。</span><br><span class="line">```go</span><br><span class="line">type Locker interface &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h5><p>互斥是保护程序中临界区的一种方式，临界区是程序中需要独占访问共享资源的区域。<code>Mutex</code>提供了一种安全的方式来表示对这些共享资源的<strong>独占访问</strong>。</p>
<blockquote>
<p>为了使用一个资源，<code>channel</code>通过通信的方式来共享内存，而<code>Mutex</code>通过开发人员的<strong>约定</strong>来同步访问共享内存。</p>
</blockquote>
<p>在使用的时候，往往会将共享资源和互斥锁绑定在一起：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewResource <span class="keyword">struct</span> &#123;</span><br><span class="line">    Resource []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Lock     *sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时通过使用<code>sync.Mutex.Lock()</code>方法和<code>sync.Mutex.Unlock()</code>方法来声明对于资源的独占开始和结束。</p>
<blockquote>
<p>最好使用 defer关键字来结束独占，否则可能因为panic引发死锁</p>
</blockquote>
<p>在此之前我们介绍了原子操作的概念，也就是一个操作的原子性。事实上我们在对于一个资源的独占期间我们绝对不想要被打断，也就是说在对于资源的操作的上下文下，我们对于资源独占期间的操作整体是具有原子性的，而又结合我们之前接触过的所谓<strong>饥饿</strong>的概念，我们知道，我们的临界区应该尽可能的小，也就是我们独占的时间应该尽可能的小。因此一个良好的Mutex的使用应该像下面这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(resource)</span></span> &#123;</span><br><span class="line">    init() <span class="comment">// 和资源无关的操作</span></span><br><span class="line">    resource.Lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> resource.Lock.Unlock()</span><br><span class="line"></span><br><span class="line">    resource.Operation() <span class="comment">// 对于资源的操作</span></span><br><span class="line">&#125;(resource_1)</span><br></pre></td></tr></table></figure>
<h5 id="RWMutex-读写互斥锁"><a href="#RWMutex-读写互斥锁" class="headerlink" title="RWMutex 读写互斥锁"></a>RWMutex 读写互斥锁</h5><p>读写锁在概念上和和互斥锁是一样的，但是读写锁让你对于内存有了更多的控制，也就是你可以单独请求一个锁用于读处理，这个情况下你将被授予访问权限。</p>
<h4 id="cond-条件变量"><a href="#cond-条件变量" class="headerlink" title="cond 条件变量"></a>cond 条件变量</h4><p><img src="https://i.loli.net/2019/06/13/5d0202140b03134769.png" alt="这是cond的截图"><br><code>Cond</code>实现了一个条件变量，是一些正在等待或者声明一个<strong>事件</strong>的goroutine的集合点。</p>
<p>每一个<code>Cond</code>都有一个相关联的锁，必须在条件改变和调用<code>wait()</code>时进行状态的改变。</p>
<p>在上述的定义中，有一个重要的概念：<strong>事件</strong>。这里的事件（Event）是指两个或者两个已上的goroutine之间的任意信号，除去这个事件已经发生之外，没有任何的信息能够被我们利用。</p>
<p>先看一下在不使用<code>cond</code>的时候我们应该怎样检查这个事件是否完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> conditionTrue() == <span class="literal">false</span> &#123;&#125;</span><br><span class="line">then()</span><br></pre></td></tr></table></figure>
<p>使用一个死循环来检查！这太聪明了！但是这样会消耗你所有的CPU时钟周期！</p>
<p>因此我们可以定时来检查一下？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !conditionTrue() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">then()</span><br></pre></td></tr></table></figure>
<p>这显然比死循环好多了，但是也是相当低效的行为，而且对于休眠的时间长度也要有所掌控：太长，会人为的降低性能；太短，会不必要地消耗大量的CPU时间。而<code>cond</code>就是为了解决这种问题而生的。</p>
<p>让我们使用<code>cond</code>来改写之前的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;) <span class="comment">// new一个新的cond</span></span><br><span class="line">cond.L.Lock() <span class="comment">// 锁定条件，因为在执行cond.Wait()的时候会自动调用Unlock()</span></span><br><span class="line"><span class="keyword">for</span> !conditionTrue() &#123;</span><br><span class="line">    cond.Wait() <span class="comment">// 开始等待，在另一个goroutine中发送信号来终止等待</span></span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock() <span class="comment">// 解锁这个条件，而Wait()方法在退出的时候会自动调用Lock()</span></span><br></pre></td></tr></table></figure>
<p><code>Wait()</code>方法不只是阻塞了goroutine，还挂起了当前的goroutine，允许其他goroutine在OS线程上运行。</p>
<p><img src="https://i.loli.net/2019/06/13/5d0218176763198286.png" alt="可以看出Wait()中的Lock和Unlock"><br>这里介绍了为什么使用循环来判定，而并非只使用<code>if</code>语句：因为当<code>Wait()</code>第一次返回的时候我们不能认为条件成立了，因此需要循环等待。但是这显然要比之前的两种方法高效多了。</p>
<p>其他的能够很好的体现的<code>cond</code>的例子，比如分配房间的例子在书中都有讲解，也挺好理解的，这里就不赘述了。</p>
<h5 id="发送信号的方式：Signal和Broadcast"><a href="#发送信号的方式：Signal和Broadcast" class="headerlink" title="发送信号的方式：Signal和Broadcast"></a>发送信号的方式：Signal和Broadcast</h5><p>golang的runtime会内部维护一个FIFO的goroutine队列，等待接收信号。<code>Signal</code>会发现等待时间最长的goroutine并且通知它，而<code>Broadcast</code>会向所有等待的goroutine发送信号。</p>
<p>这里的<code>Broadcast</code>提供了一种同时和多个goroutine通信的方式，当然，我们也可以通过<code>channel</code>对信号进行简单的复制，但是使用<code>Broadcast</code>是更加自然且高效的行为。</p>
<h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p><code>once</code>，顾名思义就是只执行一次。就很简单。就很简单。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Only do it once."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    once.Do(function)</span><br><span class="line">&#125; </span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>
<p>直觉告诉我们这句话<code>Only do it once.</code>只会输出一次。事实上确实如此。</p>
<p>这里需要注意的一点是：<code>once</code>只记录自己一共执行了多少个函数，而并非多少个不同的函数。</p>
<h4 id="Pool-池"><a href="#Pool-池" class="headerlink" title="Pool 池"></a>Pool 池</h4><p><code>Pool</code>是Pool设计模式的并发安全实现。Pool设计模式是一种可以创建和提供可供使用的固定数量的实例或者Pool实例的方法。通常用于约束<strong>创建昂贵</strong>的场景（比如数据库的连接操作）。对于<code>sync.Pool</code>，这种数据类型可以被多个goroutine安全的使用。</p>
<p><code>Pool</code>的主要的几个方法是：</p>
<ul>
<li>使用<code>Get</code>方法来获取一个池中的实例给调用者。如果池中没有则会<code>new</code>一个新的实例出来。</li>
<li>在使用完毕之后，会调用<code>Put</code>方法把实例还给池。</li>
</ul>
<h5 id="为什么使用Pool？"><a href="#为什么使用Pool？" class="headerlink" title="为什么使用Pool？"></a>为什么使用Pool？</h5><p>为什么要使用<code>Pool</code>而不是直接创建一个新的实例呢？这是因为golang有GC，因此实例化的对象会被自动清理。</p>
<p>另一个原因是，可以使用<code>Pool</code>来尽可能快的将预先分配的对象缓存加载启动。在处理代价昂贵的事务的时候这种模式可以极大的提高性能。</p>
<blockquote>
<p>当并发进程需要一个对象，并且处理它的过程会是相当的快速的过程，或者这些对象的构造过程会对内存产生负面的影响，这个时候你最好使用Pool设计模式。</p>
</blockquote>
<p>使用<code>Pool</code>时最好注意的几个点：</p>
<ul>
<li>当实例化<code>sync.Pool</code>时，使用<code>new</code>方法创建一个成员变量，在调用时会是线程安全的。</li>
<li>当你收到一个来自<code>Get</code>方法的实例的时候，不需要对接受的对象的状态进行任何的假设判定，因为一定合法的。</li>
<li>当你使用完成了一个从Pool中取出来的实例的时候，请一定使用<code>Put</code>方法把它放回去，负责你就没有办法复用这个实例了，通常情况之下会使用<code>defer</code>关键字来调用方法。</li>
</ul>
<hr>
<h3 id="channel-信道"><a href="#channel-信道" class="headerlink" title="channel 信道"></a>channel 信道</h3><blockquote>
<p>正如之前介绍过的CSP中的channel一样，你最好使用golang中的channel来进行goroutine之间的通信。而并非是用于同步内存访问。</p>
</blockquote>
<p>channel是一个用于传递信息的管道。信息从一头进，从一头出。</p>
<h4 id="创建和使用channel"><a href="#创建和使用channel" class="headerlink" title="创建和使用channel"></a>创建和使用channel</h4><p>创建一个channel非常的简单，只是需要指定一下数据的类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 声明</span></span><br><span class="line">dataStream = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure>
<p>一个普通的channel是双向的，也就是既可以输入数据，也可以读出数据。但是事实上，你也可以使用单向的channel，也就是定义一个channel，只用于发送或者接受数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 一个只用于读取的channel</span></span><br><span class="line"><span class="keyword">var</span> inputStream <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 一个只用于输入的channel</span></span><br></pre></td></tr></table></figure>
<p>golang在必要的时候会将双向的channel隐式地转换为单向的channel。</p>
<p>一个简单的小例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stringStream &lt;-<span class="string">"Hello, channels!"</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-stringStream)</span><br></pre></td></tr></table></figure>
<p>这一段程序中，按照我们之前的理解：竞争条件在这里依然存在，也就是在程序退出之前很可能都不会执行goroutine中的内容。但是事实上channel消除了竞争条件。</p>
<p>这是因为channel的输入和读出在<strong>一定条件下都会让goroutine阻塞</strong>：当channel是空，但是你想要读取数据。或者channel满了你却想输入数据的时候。</p>
<p>能够阻塞，当然也能导致DeadLock，因此在使用的时候一定要注意。</p>
<p>关闭一个channel：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(stringStream)</span><br></pre></td></tr></table></figure>
<p>读出数据的时候可以读出两个值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data, ok := &lt;-stringStream </span><br><span class="line"><span class="comment">// 第一个值是数据值，或者被关闭的通道产生的数据的默认值</span></span><br><span class="line"><span class="comment">// 第二个值是状态值，判断信道的状态是开放还是关闭，开放是true，关闭是false</span></span><br></pre></td></tr></table></figure>
<p>正因为channel的可以关闭并且有返回值的特性，我们可以使用<code>for-range</code>，并且在channel关闭的时候自动中断循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> stringStream &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带缓冲的信道-buffered-channel"><a href="#带缓冲的信道-buffered-channel" class="headerlink" title="带缓冲的信道 buffered channel"></a>带缓冲的信道 buffered channel</h4><p>所谓<code>buffered channel</code>就是一个有缓冲容量的信道，我们在之前看到的channel其实就是缓冲容量为0的信道。我们在声明一个新的信道的时候就可以指定缓冲容量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>带缓冲的channel是一个内存中的FIFO队列，用于并发进程之间的通信。</p>
<p>两个比较生动形象的图：</p>
<p><img src="https://i.loli.net/2019/06/13/5d023f66d97b699629.png" alt><br><img src="https://i.loli.net/2019/06/13/5d023fa85203120841.png" alt></p>
<h4 id="channel上的操作和相应的结果"><a href="#channel上的操作和相应的结果" class="headerlink" title="channel上的操作和相应的结果"></a>channel上的操作和相应的结果</h4><table>
<thead>
<tr>
<th>操作</th>
<th>Channel的状态</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read</td>
<td>nil</td>
<td>阻塞</td>
</tr>
<tr>
<td></td>
<td>打开且非空</td>
<td>输出值</td>
</tr>
<tr>
<td></td>
<td>打开但是空</td>
<td>阻塞</td>
</tr>
<tr>
<td></td>
<td>关闭</td>
<td>&lt;默认值&gt;，false</td>
</tr>
<tr>
<td></td>
<td>只写</td>
<td>编译错误</td>
</tr>
<tr>
<td>Write</td>
<td>nil</td>
<td>阻塞</td>
</tr>
<tr>
<td></td>
<td>打开且满</td>
<td>阻塞</td>
</tr>
<tr>
<td></td>
<td>打开且不满</td>
<td>写入值</td>
</tr>
<tr>
<td></td>
<td>关闭</td>
<td>panic</td>
</tr>
<tr>
<td></td>
<td>只读</td>
<td>编译错误</td>
</tr>
<tr>
<td>close</td>
<td>nil</td>
<td>panic</td>
</tr>
<tr>
<td></td>
<td>打开且非空</td>
<td>关闭channel；读取成功，直到信道内值耗尽，然后读取产生值的默认值</td>
</tr>
<tr>
<td></td>
<td>打开但是空</td>
<td>关闭channel；读到生产者的默认值</td>
</tr>
<tr>
<td></td>
<td>关闭的</td>
<td>panic</td>
</tr>
<tr>
<td></td>
<td>只读</td>
<td>编译错误</td>
</tr>
</tbody>
</table>
<h4 id="使用channel的基本素养"><a href="#使用channel的基本素养" class="headerlink" title="使用channel的基本素养"></a>使用channel的基本素养</h4><p>所谓<strong>基本素养</strong>，其实就是规范使用channel的方法，从而规避死锁和panic的风险。</p>
<p>一个拥有channel的goroutine应该有以下操作：</p>
<ul>
<li><ol>
<li>实例化channel</li>
</ol>
</li>
<li><ol start="2">
<li>执行写操作，或者将channel的所有权传递给其他goroutine</li>
</ol>
</li>
<li><ol start="3">
<li>关闭channel</li>
</ol>
</li>
<li><ol start="4">
<li>将1-3项封装好，并且通过一个只读channel将其暴露出来</li>
</ol>
</li>
</ul>
<h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><blockquote>
<p>channel是goroutine之间的粘合剂，而select语句则是channel之间的粘合剂。</p>
</blockquote>
<p>如何使用select语句呢？下面是一个简单的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chan1, chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> chan3 <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> &lt;-chan2:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> c3&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和switch语句是很像，但是select语句中的case语句没有测试顺序，即使没有满足任何条件，执行也不会失败。而且一个很大的特性是：golang运行时会将一组case语句中执行伪随机选择。</p>
<p>使用伪随机选择的原因是，golang无法解析select语句的意图，也就是说，它不能推断出问题空间，或者说为什么将一组channel组合在一个select语句中。在这种情况下，最好的选择就是平均情况下运行良好。</p>
<h4 id="为select语句设置超时时间"><a href="#为select语句设置超时时间" class="headerlink" title="为select语句设置超时时间"></a>为select语句设置超时时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channel:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span>*time.Second):</span><br><span class="line">    <span class="comment">// ...超时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="select语句中的default"><a href="#select语句中的default" class="headerlink" title="select语句中的default"></a>select语句中的default</h4><p>在select中也存在default语句，执行的条件是全部的channel都是阻塞的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channel:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...几乎是瞬间执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用for-select结构在等待同时工作"><a href="#使用for-select结构在等待同时工作" class="headerlink" title="使用for-select结构在等待同时工作"></a>使用for-select结构在等待同时工作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> channel:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...工作语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="永远阻塞的语句也永远最简单"><a href="#永远阻塞的语句也永远最简单" class="headerlink" title="永远阻塞的语句也永远最简单"></a>永远阻塞的语句也永远最简单</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个语句将永远阻塞</p>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Concurrency-In-Go/">Concurrency In Go</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://shiinaorez.github.com/2019/06/14/concurrency-in-go-3/" data-title="《Concurrency in Go》阅读笔记 -- 第三章：Go语言并发组件 | Shiina Orez" data-tsina class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2019/05/31/concurrency-in-go-2/" title="《Concurrency in Go》阅读笔记 -- 第二章：对你的代码建模，通信顺序进程">
 <strong>NEXT:</strong><br> 
 <span>《Concurrency in Go》阅读笔记 -- 第二章：对你的代码建模，通信顺序进程
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#《Concurrency-in-Go》"><span class="toc-number">1.</span> <span class="toc-text">《Concurrency in Go》</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Chapter-3：Go’s-Concurrency-Building-Blocks-Go-语言并发组件"><span class="toc-number">1.1.</span> <span class="toc-text">Chapter 3：Go’s Concurrency Building Blocks Go 语言并发组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#goroutine"><span class="toc-number">1.1.1.</span> <span class="toc-text">goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是goroutine？"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">什么是goroutine？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine的独到之处（和普通协程的区别）"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">goroutine的独到之处（和普通协程的区别）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine怎么实现并发"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">goroutine怎么实现并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine中闭包运行的情况"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">goroutine中闭包运行的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine有多么的轻量级"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">goroutine有多么的轻量级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Package-sync"><span class="toc-number">1.1.2.</span> <span class="toc-text">Package sync</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WaitGroup"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">WaitGroup</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mutex-amp-RWMutex"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">Mutex &amp; RWMutex</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Mutex-互斥锁"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">Mutex 互斥锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RWMutex-读写互斥锁"><span class="toc-number">1.1.2.2.2.</span> <span class="toc-text">RWMutex 读写互斥锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cond-条件变量"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">cond 条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#发送信号的方式：Signal和Broadcast"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">发送信号的方式：Signal和Broadcast</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#once"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">once</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Pool-池"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">Pool 池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么使用Pool？"><span class="toc-number">1.1.2.5.1.</span> <span class="toc-text">为什么使用Pool？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel-信道"><span class="toc-number">1.1.3.</span> <span class="toc-text">channel 信道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建和使用channel"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">创建和使用channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#带缓冲的信道-buffered-channel"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">带缓冲的信道 buffered channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel上的操作和相应的结果"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">channel上的操作和相应的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用channel的基本素养"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">使用channel的基本素养</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select语句"><span class="toc-number">1.1.4.</span> <span class="toc-text">select语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为select语句设置超时时间"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">为select语句设置超时时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select语句中的default"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">select语句中的default</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用for-select结构在等待同时工作"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">使用for-select结构在等待同时工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#永远阻塞的语句也永远最简单"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">永远阻塞的语句也永远最简单</span></a></li></ol></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Algorithm/" title="Algorithm">Algorithm<sup>1</sup></a></li>
		
			<li><a href="/tags/Algorithm-DataStructure/" title="Algorithm DataStructure">Algorithm DataStructure<sup>1</sup></a></li>
		
			<li><a href="/tags/Concurrency-In-Go/" title="Concurrency In Go">Concurrency In Go<sup>1</sup></a></li>
		
			<li><a href="/tags/Concurrency-in-Go/" title="Concurrency in Go">Concurrency in Go<sup>2</sup></a></li>
		
			<li><a href="/tags/Werkzeug/" title="Werkzeug">Werkzeug<sup>4</sup></a></li>
		
			<li><a href="/tags/algorithm/" title="algorithm">algorithm<sup>12</sup></a></li>
		
			<li><a href="/tags/base/" title="base">base<sup>1</sup></a></li>
		
			<li><a href="/tags/go/" title="go">go<sup>1</sup></a></li>
		
			<li><a href="/tags/kotlin/" title="kotlin">kotlin<sup>1</sup></a></li>
		
			<li><a href="/tags/python/" title="python">python<sup>2</sup></a></li>
		
			<li><a href="/tags/ubuntu-QT/" title="ubuntu QT">ubuntu QT<sup>1</sup></a></li>
		
			<li><a href="/tags/软件体系结构/" title="软件体系结构">软件体系结构<sup>2</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer">
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 做一个真正的菜鸡 --ShiinaOrez <br>
			日积代码千行，则无往而不利也@学业进行中</p>
	</section>
	 
	<div class="social-font clearfix">
		
		
		<a href="https://twitter.com/shiina_orez" target="_blank" title="twitter"></a>
		
		
		<a href="https://github.com/ShiinaOrez" target="_blank" title="github"></a>
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2019 
		
		<a href="http://shiinaorez.github.com" target="_blank" title="Shiina Orez">Shiina Orez</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
