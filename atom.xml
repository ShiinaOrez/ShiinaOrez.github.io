<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shiina Orez</title>
  
  <subtitle>Backend coder, coding every day.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shiinaorez.github.com/"/>
  <updated>2020-02-28T15:41:09.064Z</updated>
  <id>http://shiinaorez.github.com/</id>
  
  <author>
    <name>Shiina Orez</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python使用docxtpl渲染docx文件和Linux转换docx为pdf</title>
    <link href="http://shiinaorez.github.com/2020/02/28/python-docxtpl-pdf/"/>
    <id>http://shiinaorez.github.com/2020/02/28/python-docxtpl-pdf/</id>
    <published>2020-02-28T14:32:29.000Z</published>
    <updated>2020-02-28T15:41:09.064Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Python以jinja2方式渲染docx文件-docxtpl"><a href="#使用Python以jinja2方式渲染docx文件-docxtpl" class="headerlink" title="使用Python以jinja2方式渲染docx文件: docxtpl"></a>使用Python以jinja2方式渲染docx文件: docxtpl</h2><h3 id="起因"><a href="#起因" class="headerlink" title="起因:"></a>起因:</h3><p>在给LCY老师写国家语言委员会的申报平台时, 遇到了以下的需求:</p><ul><li>需要按照每个申报流程中的数据动态生成PDF文件进行下载</li><li>PDF可以按照申报书不同部分进行拼接</li></ul><p>这个需求当初提出时, 我的第一思路是直接根据HTML生成PDF, 以HTML生成表格等等. 再将数据进行嵌入, 最后利用chrome的kernel来进行生成PDF.</p><p>这个思路源于当初给PHU老师写的一个爬虫程序, 当时是把Python官方的教程以PDF电子书的形式进行整合下载, 当时就是利用的chrome kernel进行PDF的生成. 因此我当时第一反应就是这样去做.</p><p>后来发现HTML的表格还挺难写的, (当时是CGH负责这方面的功能), 我意识到这个事情有难度, 直到后面这个功能落在我的头上的时候, 我开始重新思考解决方案.</p><p>能不能做一个docx模板呢, 我当时的想法是这样的, 后来发现还真的可以…</p><h3 id="使用Python操作docx文件-python-docx和docxtpl包"><a href="#使用Python操作docx文件-python-docx和docxtpl包" class="headerlink" title="使用Python操作docx文件: python-docx和docxtpl包"></a>使用Python操作docx文件: python-docx和docxtpl包</h3><p>使用Python操作docx文件在网上最多的答案是使用python-docx包, 而这个包的强大之处不是在于修改docx文件而是在于创建docx文件. python-docx中对于文档内容的修改是比较复杂和繁琐的.</p><p>docxtpl包(docx template)的目的就是为了将docx能够以模板的形式进行编辑, 它依赖于python-docx和jinja 2包.</p><p><a href="https://blog.csdn.net/meteor_cheng/article/details/88582426" target="_blank" rel="noopener">关于docxtpl-CSDN</a></p><h3 id="具体使用docxtpl来进行docx文档的编辑"><a href="#具体使用docxtpl来进行docx文档的编辑" class="headerlink" title="具体使用docxtpl来进行docx文档的编辑"></a>具体使用docxtpl来进行docx文档的编辑</h3><p>docxtpl的使用非常的简单, 只需要准备好一个docx文件, 其中需要渲染数据的地方以jinja 2标签的方式进行填补就可以了.</p><p>如果是学过flask的同学一定对于jinja 2标签渲染不会陌生. 因为在flask狗书的开头就会使用flask+boostrap+jinja 2来进行一个前后端合并网站的搭建的.</p><p>这里截图举例一个非常简单的docx文档例子:</p><p><img src="https://i.loli.net/2020/02/28/NzZRx1cM7ltpDJi.png" alt></p><p>可以看出我们在需要替换模板数据的地方可以很好的使用jinja 2类标签进行填充.</p><p>然后我们可以使用以下代码进行替换(部分数据):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> docxtpl <span class="keyword">import</span> DocxTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># temp.docx是我们的模板docx文件</span></span><br><span class="line">tpl = DocxTemplate(<span class="string">"temp.docx"</span>)</span><br><span class="line"><span class="comment"># context是我们需要渲染的数据, 是dict类型</span></span><br><span class="line">context = &#123;</span><br><span class="line">    <span class="string">"data_1"</span>: <span class="string">"xxx"</span>,</span><br><span class="line">    <span class="string">"data_2"</span>: <span class="string">"yyy"</span>,</span><br><span class="line">    <span class="string">"data_3"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"field_1"</span>: <span class="string">"111"</span>,</span><br><span class="line">            <span class="string">"field_2"</span>: <span class="string">"222"</span>,</span><br><span class="line">            <span class="string">"field_3"</span>: <span class="number">333</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 渲染</span></span><br><span class="line">tpl.render(context)</span><br><span class="line"><span class="comment"># 保存为gen.docx</span></span><br><span class="line">tpl.save(<span class="string">"gen.docx"</span>)</span><br></pre></td></tr></table></figure><p>可以看出使用docxtpl我们可以很轻松的完成对于docx模板内容的操控.</p><h3 id="Linux使用libreoffice在子线程上进行docx到PDF的转换"><a href="#Linux使用libreoffice在子线程上进行docx到PDF的转换" class="headerlink" title="Linux使用libreoffice在子线程上进行docx到PDF的转换"></a>Linux使用libreoffice在子线程上进行docx到PDF的转换</h3><p>有了渲染好的docx文件后, 就要进行从docx到PDF文件的转换了, 在网络上找到了很多的方法, 但是很多python的包都是针对于Windows进行转换的, Linux并没有直接用于docx到PDF转换的包, 这个是很令人沮丧的一件事情.</p><p>但是也不是完全没有办法, 我们可以利用在Linux上的强大软件Libreoffice: 开辟一个子线程, 然后使用Libreoffice的功能进行转换:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LibreOfficeError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, output)</span>:</span></span><br><span class="line">        self.output = output</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to</span><span class="params">(folder, source, timeout=None)</span>:</span></span><br><span class="line">    args = [<span class="string">'libreoffice'</span>, <span class="string">'--headless'</span>, <span class="string">'--convert-to'</span>, <span class="string">'pdf'</span>, <span class="string">'--outdir'</span>, folder, source]</span><br><span class="line">    process = subprocess.run(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, timeout=timeout)</span><br><span class="line">    filename = re.search(<span class="string">'-&gt; (.*?) using filter'</span>, process.stdout.decode())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> filename <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">raise</span> LibreOfficeError(process.stdout.decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> filename.group(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用Python以jinja2方式渲染docx文件-docxtpl&quot;&gt;&lt;a href=&quot;#使用Python以jinja2方式渲染docx文件-docxtpl&quot; class=&quot;headerlink&quot; title=&quot;使用Python以jinja2方式渲染docx文件:
      
    
    </summary>
    
    
    
      <category term="Python" scheme="http://shiinaorez.github.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Elastic Search安装教程</title>
    <link href="http://shiinaorez.github.com/2020/02/28/elastic-search-install/"/>
    <id>http://shiinaorez.github.com/2020/02/28/elastic-search-install/</id>
    <published>2020-02-27T16:35:10.000Z</published>
    <updated>2020-02-27T18:40:33.687Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elastic-Search-安装教程"><a href="#Elastic-Search-安装教程" class="headerlink" title="Elastic Search 安装教程"></a>Elastic Search 安装教程</h2><p>本文是俺在学习Elastic Search时安装的一些步骤和教程, 包括了对于ES中的分词插件的安装等等.</p><h3 id="学习Elastic-Search的契机"><a href="#学习Elastic-Search的契机" class="headerlink" title="学习Elastic Search的契机"></a>学习Elastic Search的契机</h3><p>源自我在学校时的一个开源项目: 木犀课栈, 不知道以后看到这个文章的时候这个项目是否还在hhh, 暂且纪念一下吧… 当时要满足对于课程的搜索, 大致的场景如下:</p><ul><li>支持全文搜索(对于课程名, 开课教师名, 课程号)</li><li>支持对于tag的检索</li><li>支持多种筛选条件</li></ul><p>当时适逢老板(zxh)送给我一本&lt;&lt;高性能MySQL&gt;&gt;(o’reilly Baron Scbwartz等, High Performance MySQL), 我就使用了MySQL里的FULLTEXT(全文索引, 在MySQL 4.x后引入), 结合MATCH和AGAINST两个函数以及多个MySQL函数实现了当时要求的功能. 并且当时觉得自己非常的厉害来着…</p><p>使用MySQl+golang编写当时的代码时, 真的是费劲了各种心机, 各种优化, 最终把性能维护在了一个还不错的程度. 当时又恰逢去字节跳动(base武汉)实习, 我的Leader问起我在校内写过的项目, 我就提起了这个搜索的部分, 并且还有点骄傲… ? 因为当时真的想了很多办法去优化.</p><p>我的Leader听我讲了一下情况, 就问我为什么不用ES, 我当时知道ES是一个搜索引擎, 但是觉得太重了, 所以就说因为ES太重了所以没有尝试, 后来Leader说ES一点儿也不重, 可以试一试. 于是有了后来学习ES的过程.</p><p>(后来发现ES对于我们这种校内的团队的情况还是很重的, 干, 根本负担不起)</p><h3 id="下载-安装Elastic-Search"><a href="#下载-安装Elastic-Search" class="headerlink" title="下载/安装Elastic Search"></a>下载/安装Elastic Search</h3><p>Elastic Search是一个完全开源的搜索引擎, 基于Lucene, 集成了RESTful的API调度方式, <a href="https://www.elastic.co/" target="_blank" rel="noopener">官网</a>上可以下载对应的安装包, 我当时下载的是7.5.2版本(我在写这篇文章的时候已经是7.6.0版本了, 可以看出还是比较活跃的), 由于各个版本ES有比较大的改动, 因此还是建议下载最新的版本.</p><p>当然, 不管是哪个版本的ES都是稳定的, 因此你也可以选择下载比较小的ES 2.x来进行测试和部署, 网络上有各个版本的ES的文档, 都可以很好的进行查阅.</p><p>(下载的时候由于墙的原因会比较慢, 因此建议开梯子进行下载)</p><p>下载好之后进行解压:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf elasticsearch-7.5.2-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压后进入文件夹内, 直接运行二进制的文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-7.5.2 &amp;&amp; ./bin/elasticsearch</span><br></pre></td></tr></table></figure><p>然后就会运行起来啦~但是需要JDK-8, 建议提前安装好哦~</p><h3 id="安装Elastic-Search中文分词插件IK"><a href="#安装Elastic-Search中文分词插件IK" class="headerlink" title="安装Elastic Search中文分词插件IK"></a>安装Elastic Search中文分词插件IK</h3><p>ES对于存储数据的内容进行全文索引, 这其中很重要的一环就是需要对于内容进行<strong>分词</strong>, 只有在进行适当的分词之后才可以建立合适的索引, 否则就无法进行全文检索.</p><p>我们从ES官网下载的文件中并没有自带中文的分词插件, 这个时候就需要我们进行手动安装了, 我下载使用的是ik, 好在ES给我们提供了很便捷的安装插件的功能:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.5.2/elasticsearch-analysis-ik-7.5.2.zip</span><br></pre></td></tr></table></figure><p>然后我们在使用ES的时候就可以通过tokenizer字段来指定对应安装的分词器了.</p><h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>随着我对于ES的学习越来越深入, 我发现相比起之前使用了大量的原生SQL语句和各种优化技巧相比, 直接使用ES是更加的轻松和方便的. 而且ES提供了人性化的RESTful API和很强大的检索功能, 很适合我当时的应用场景.</p><p>但是在我盲目开心的时候, 发现了一个很致命的问题: ES对于内存的需求不是我们这个团队当前的条件可以负担的起的… 所以没有办法我最后还是使用了之前的版本.</p><p>虽然很可惜, 但是以后在我漫长的开发生涯中, 我一定有机会能够使用ES, 能够和这个能够为我提供简便全文检索的朋友相见, 就这样.</p><p>– 2020.02.28</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elastic-Search-安装教程&quot;&gt;&lt;a href=&quot;#Elastic-Search-安装教程&quot; class=&quot;headerlink&quot; title=&quot;Elastic Search 安装教程&quot;&gt;&lt;/a&gt;Elastic Search 安装教程&lt;/h2&gt;&lt;p&gt;本文
      
    
    </summary>
    
    
    
      <category term="ES" scheme="http://shiinaorez.github.com/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>TLV和TTLV - 编码规范的历史</title>
    <link href="http://shiinaorez.github.com/2019/10/02/tlv-ttlv/"/>
    <id>http://shiinaorez.github.com/2019/10/02/tlv-ttlv/</id>
    <published>2019-10-02T15:49:55.000Z</published>
    <updated>2019-10-02T15:52:40.170Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知, 在Protobuf中使用的编码方式是TLV, 也就是Tag-Length-Value, 但是在单纯的理解TLV是什么之前, 我认为需要去理解一下编码规范的历史, 因此写了这篇文章:</p><h2 id="一-紧凑时代"><a href="#一-紧凑时代" class="headerlink" title="一, 紧凑时代"></a>一, 紧凑时代</h2><blockquote><p>时代背景是刚刚有类似DOS的时候, 这个时候的显著特征就是各方面都很原始, 带宽很低, 因此在传输数据的时候要省之又省, 因此协议的编码规范以紧凑为特点.</p></blockquote><p>假设武大和华师要搞一个数据传输协议, 目的是传输一本书的信息, 然后两个学校商量好了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cmd; <span class="comment">// 代表不同的操作</span></span><br><span class="line">    <span class="keyword">char</span>[<span class="number">8</span>]  num;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">60</span>] name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学校觉得应该是可以的, 这个协议可以很好的沟通数据了! 也非常的节省空间!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+---+----+</span><br><span class="line">|cmd|num|name|</span><br><span class="line">+---+---+----+</span><br><span class="line">| 2 | 8 | 60 |</span><br><span class="line">+---+---+----+</span><br></pre></td></tr></table></figure><p>这种编码规范的特点就是紧凑, 对于空间的利用率高, 导致这样的特征出现是因为当时的时代环境所限制, 带宽是非常珍贵的, 因此能省则省, 不允许冗余字段的产生.</p><h2 id="二-Version的出现"><a href="#二-Version的出现" class="headerlink" title="二, Version的出现"></a>二, Version的出现</h2><p>在两三年后, 武大想在这个数据传输协议中增加一个字段: 入馆日期. 我们可以叫它<code>date</code>, 然后我们的结构体可以这样去写:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cmd; <span class="comment">// 代表不同的操作</span></span><br><span class="line">    <span class="keyword">char</span>[<span class="number">8</span>] num;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">60</span>] name;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">8</span>] date; <span class="comment">// 日期存储的形式为: 19990101这种</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯, 这样安排应该也挺紧凑的, 但是问题很快就凸显了出来: 接收方无法判断应该按照旧的方式去解析数据帧还是按照新的方式去解析数据帧, 因为不可能一夜之间所有的服务都按照新的编码规范来传输数据. 因此一个叫做版本号的字段就这样诞生了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BookInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> version; <span class="comment">// 版本字段, 用于标识当前的版本号</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> cmd;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">8</span>] num;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">60</span>] name;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">8</span>] date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+---+---+----+----+</span><br><span class="line">|version|cmd|num|name|date|</span><br><span class="line">+-------+---+---+----+----+</span><br><span class="line">|   1   | 2 | 8 | 60 | 4  |</span><br><span class="line">+-------+---+---+----+----+</span><br></pre></td></tr></table></figure><p>这样根据版本号就可以使用不同的解析方式, 也就解决了之前的问题, 在这里其实版本号就是一个冗余的字段, 但是由于这个字段本身占用的空间不大, 而且当时的带宽已经比之前宽松了一点. 这样的方式现在还有不少协议都在使用.</p><h2 id="三-Tag的出现"><a href="#三-Tag的出现" class="headerlink" title="三. Tag的出现"></a>三. Tag的出现</h2><p>虽然有了版本号能够让我们在协议的构建的时候能够拥有一定的可扩展性, 但是一个协议仅有一个冗余字段来维护还是略显单薄了一些: 当我们拥有很多个版本的协议的时候, 意味着我们的代码里将会出现相当多的<code>case</code>, 然后我们的代码就会变得非常的臃肿, 所以我们尝试加入更多的冗余信息: <code>tag</code>.</p><p><code>tag</code>的作用是用来标识一个字段的解析方式, 一个特定的<code>tag</code>可以用于标识一个字段, 这个字段的解析方式完全可以通过<code>tag</code>来判断, 解析数据帧的时候就可以通过遇见的<code>tag</code>来解析接下来一个或几个字节的数据. 这样就可以拥有更好的可扩展性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+---+---+---+---+---+----+---+----+</span><br><span class="line">|version|tag|cmd|tag|num|tag|name|tag|date|</span><br><span class="line">+-------+---+---+---+---+---+----+---+----+</span><br><span class="line">|   1   | 1 | 2 | 1 | 8 | 1 | 60 | 1 | 4  |</span><br><span class="line">+-------+---+---+---+---+---+----+---+----+</span><br></pre></td></tr></table></figure><h2 id="四-TLV和TTLV"><a href="#四-TLV和TTLV" class="headerlink" title="四, TLV和TTLV"></a>四, TLV和TTLV</h2><p><strong>1. TLV</strong></p><p>在使用了Tag之后, 我们程序的可扩展性好了很多, 但是有时候会出现这样的情况: 我们的书名可能只占4个或者5个字节, 但是仍然分配了60个字节的空间, 这显然有点浪费吧! 所以人们就想着加上后续的长度这类冗余信息会不会让协议变得更加高效?</p><p>好在这种形式早在<a href="https://baike.baidu.com/item/ASN.1/498523" target="_blank" rel="noopener">ASN.1</a>中的BER(Basic Encoding Rule)中提出了:</p><blockquote><p>BER的数据由三个域组成: 标识域(tag), 长度域(length)和值域(value), 又叫做TLV</p></blockquote><p>也就是说, 一个数据段由三个部分组成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---+------+-----+</span><br><span class="line">|tag|length|value|</span><br><span class="line">+---+------+-----+</span><br></pre></td></tr></table></figure><p><code>tag</code>的作用是用于标识字段是什么, <code>length</code>用于告知解析程序后续的值域的字节长度, <code>value</code>用于存储真正的数据.</p><p>而且TLV的模式还可以嵌套使用.</p><p>这样的TLV其实已经够棒了, 对吗? 因为我们已经牺牲了足够多的冗余空间来帮助我们达成数据传输协议的高可扩展性, 当数据传输中不定长的字段比较多的时候这样往往是很有效的, 但是如果字段都是占用空间比较小的时候(比如说字符和一些数值), TLV并没有很大的提升整体解析的效率. 并且TLV这样一种模式不具有<strong>自解释性</strong>.</p><blockquote><p>所谓自解释性, 是指可以通过阅读代码或者数据包本身来知晓其结构和特征, 而不需要依靠特定的文档来实现.</p></blockquote><p>比如我们希望随便抓一个数据包, 就能知道每个字段的键, 类型等等信息.</p><p><strong>2. TTLV</strong></p><p>所谓的TTLV, 是指<strong>Tag, Type, Length, Value</strong>, 在这其中加上了Type, 就能够在数据中直接知晓一个数据段的数据类型, 相应的, 在一些确定长度的类型下, 我们还可以删减掉长度这个辅助信息[所以其实是<strong>TT(L)V</strong>], 这样接收方就能够只看数据包而知晓数据传输协议的编码规范.</p><p>比如我们定义了几个类型: <code>int8</code>用<code>1</code>表示, <code>int32</code>用<code>2</code>表示, <code>string</code>用<code>3</code>表示, 这样的话<code>int8</code>和<code>int32</code>的值域其实是定长的, 而只有<code>string</code>类型的字段是需要长度域的, 比如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Info <span class="keyword">struct</span> &#123;</span><br><span class="line">    One   <span class="keyword">int8</span></span><br><span class="line">    Two   <span class="keyword">int32</span></span><br><span class="line">    Three <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个Go语言中的结构体, 如果我们传输他的话, 按照TTLV的形式, 数据帧的编码规范应该是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---+----+-----+---+----+-----+---+----+------+-----+</span><br><span class="line">|tag|type|value|tag|type|value|tag|type|length|value|</span><br><span class="line">+---+----+-----+---+----+-----+---+----+------+-----+</span><br><span class="line">|   | 1  |1-bit|   | 2  |4-bit|   | 3  |  x   |x-bit|</span><br><span class="line">+---+----+-----+---+----+-----+---+----+------+-----+</span><br></pre></td></tr></table></figure><p>编码规范的演化, 一方面受着<strong>物理环境因素的影响(指带宽)</strong>, 另一方面受<strong>人类需求</strong>的影响, 所以在使用TLV或者TTLV之前一定要了解整个编码规范的历史进程, 这样才能更好的理解为什么会出现TLV和TTLV.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知, 在Protobuf中使用的编码方式是TLV, 也就是Tag-Length-Value, 但是在单纯的理解TLV是什么之前, 我认为需要去理解一下编码规范的历史, 因此写了这篇文章:&lt;/p&gt;
&lt;h2 id=&quot;一-紧凑时代&quot;&gt;&lt;a href=&quot;#一-紧凑时代&quot; cl
      
    
    </summary>
    
    
    
      <category term="Protobuf" scheme="http://shiinaorez.github.com/tags/Protobuf/"/>
    
  </entry>
  
  <entry>
    <title>面对小数值的高效率序列化方案:varints和zigzag编码</title>
    <link href="http://shiinaorez.github.com/2019/09/30/varintsAndZigZag/"/>
    <id>http://shiinaorez.github.com/2019/09/30/varintsAndZigZag/</id>
    <published>2019-09-30T08:12:45.000Z</published>
    <updated>2019-10-21T12:32:23.755Z</updated>
    
    <content type="html"><![CDATA[<p>序列化是在传输数据的时候非常重要的一环, 而对于如何高效的序列化数字一直是人们非常关心的问题, 在历史的长河中也有很多的工程师提出了有效的序列化方案, 这篇文章就讲一下在protobuf中使用到的两种数字序列化编码方案: <strong>varints</strong>和<strong>zigzag</strong></p><hr><h3 id="varints"><a href="#varints" class="headerlink" title="varints"></a>varints</h3><p><strong>可变长</strong>编码方案, 用于把整数进行<strong>序列化</strong>, 在序列化一些大概率比较小的整数的时候效率会好一些.</p><p>我们传输时使用的是一个字节流, 也就是由byte组成的bytes. 我们在各个语言中声明的整数都是有固定的大小的: 比如说四个字节大小. 但是如果一些数字本身的取值范围就很小, 那么在序列化时就会产生很多的浪费, 因为前几个字节位很可能都是由0组成的. 因此varints就是为了能够在序列化整数时能够有更好的效率而产生的一种编码方式.</p><p>varints将每一个字节(8-bit)中的第一bit抽出用于标识是否还有后续字节, 剩余7-bit用来表示内容, 而在组合的时候则是逆序组合, 就像下面这样:</p><p>十进制: <code>2019</code> -&gt; 二进制: <code>111 11100011</code></p><p>假设这个数字是使用<code>golang</code>中的<code>uint</code>类型存储的, 那么它应该占用了内存中<code>32-bit</code>的空间, 也就是<code>4</code>个字节:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000000 00000111 11100011</span><br></pre></td></tr></table></figure><p>我们在传输的时候真的太难受了: 白白浪费了两个字节的空间! 那么我们使用<code>varints</code>来进行一下编码吧! 或许会更好一些!</p><p>首先第一步, 把原来的串按照<code>7-bit</code>拆分, 舍去多余的前导0:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">111 11100011 -&gt; 0001111 1100011</span><br></pre></td></tr></table></figure><p>然后第二步, 把所有的<code>7-bit</code>片逆序排列:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> byte2   byte1      byte1   byte2</span><br><span class="line">0001111 1100011 -&gt; 1100011 0001111</span><br></pre></td></tr></table></figure><p>然后在每个非结尾<code>7-bit</code>片前面加上<code>1</code>, 在最后一个<code>7-bit</code>片前加上<code>0</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1100011 0001111 -&gt; 1_1100011 0_0001111</span><br></pre></td></tr></table></figure><p>而最后我们得到了两个<code>8-bit</code>字节: 我们可以用它来进行传输啦! 而且我们省去了两个字节!</p><p>大家一定可以发现一些使用<code>varints</code>的限制和缺陷:</p><ul><li>首先, varints会把数字表示的最大范围缩小, 比如uint使用varints就只能表示2^28, 这是因为极端情况缺少了4个标志位.</li><li>其次, 在一个变量频繁的大于2^22次方时, 我们编码后也不会节省任何的空间, (为了不失真甚至还有可能变大), 因此varints编码只适用于相对较小的数字的序列化.</li><li>如果序列化的数字对象为负数, 则和上一种情况类似, 不会有任何空间的节省. 因为符号位在最前会被视为很大的一个数.</li></ul><p>但是在面对<strong>较小的数字</strong>的时候, <code>varints</code>的效果是非常显著的.</p><hr><h3 id="zig-zag"><a href="#zig-zag" class="headerlink" title="zig zag"></a>zig zag</h3><p>zig zag是将有符号数统一映射到无符号数的一种编码方式, 从结果来看可以看出其名字的由来: 0, -1, 1, -2, 2 编码后变为了 0, 1, 2, 3, 4. 负数和正数以绝对值不断增大的方式来回在数轴上跳跃穿插.也就是zig zag.</p><p>我们从极端情况来看zig zag的解决方案: -1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 1 -&gt; 00000000 00000000 00000000 00000001</span><br><span class="line">-1 -&gt; 11111111 11111111 11111111 11111111</span><br></pre></td></tr></table></figure><p>对于1而言, 无论是zig zag还是varints都会相对而言觉得很好处理, 因为传输时的主要思想就是对于前导0的省略, 而对于负数的补码而言, 有大量的前导1出现在字节中, 这就导致了编码上的困难.</p><p>是什么导致了这种情况呢? 一是因为<strong>符号位放在最前</strong>, 二是因为负数<strong>取补码</strong>时将大量的0都变成了1.</p><p>对于第一个原因, 工程师们决定把符号位重新编码放到最后, 而对于第二个原因, 工程师们决定对于负数把除了符号位以外的位都反转过来. 而对于正数则不变(除了将符号位也放在最后)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                                             符号位</span><br><span class="line">zig_zag(1): 00000000 00000000 00000000 0000001_0</span><br><span class="line">zig_zag(-1):00000000 00000000 00000000 0000000_1</span><br></pre></td></tr></table></figure><p>所以就出现了像我们一开头提到的情况: 正数和负数来来回回的映射到正数数轴上.</p><p>我们可以使用C++简单的位运算来实现<code>zig zag</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zigzag</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (num &lt;&lt; <span class="number">1</span>) ^ (n &gt;&gt; <span class="number">31</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>varints</code>将无用的字节省略掉, <code>zig zag</code>则解决了负数的问题, 但是这二者在面对绝对值较大的数字时都是非常无力的, 因此在应用时应当分清不同的场景, 仅有在序列化绝对值较小的数字时才会使用这两种编码方式.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;序列化是在传输数据的时候非常重要的一环, 而对于如何高效的序列化数字一直是人们非常关心的问题, 在历史的长河中也有很多的工程师提出了有效的序列化方案, 这篇文章就讲一下在protobuf中使用到的两种数字序列化编码方案: &lt;strong&gt;varints&lt;/strong&gt;和&lt;
      
    
    </summary>
    
    
    
      <category term="protocol buffers" scheme="http://shiinaorez.github.com/tags/protocol-buffers/"/>
    
  </entry>
  
  <entry>
    <title>构建一个高性能现代网络爬虫</title>
    <link href="http://shiinaorez.github.com/2019/09/25/building-a-fast-modern-crawler/"/>
    <id>http://shiinaorez.github.com/2019/09/25/building-a-fast-modern-crawler/</id>
    <published>2019-09-25T10:09:49.000Z</published>
    <updated>2019-09-25T11:24:54.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建一个高性能现代网络爬虫"><a href="#构建一个高性能现代网络爬虫" class="headerlink" title="构建一个高性能现代网络爬虫"></a>构建一个高性能现代网络爬虫</h1><p>PS:本文为<a href="https://creekorful.me/building-fast-modern-web-crawler/" target="_blank" rel="noopener">Building a fast modern web crawker</a>的中文译文。</p><p>我一直对于爬虫具有很强烈的兴趣。我曾经使用过多种语言比如C++，Node.JS，Python等等来撰写爬虫程序，并且更吸引我的是爬虫背后的理论。</p><p>但是首先我们要讨论的问题是：什么是爬虫？</p><h2 id="什么是爬虫？"><a href="#什么是爬虫？" class="headerlink" title="什么是爬虫？"></a>什么是爬虫？</h2><p>爬虫是一个通过浏览整个因特网从而去定位一些存在的页面、图片、PDF等等的计算机程序，并且允许用户去通过一个搜索引擎去检索它们。这就是隐藏在著名的Google搜索引擎背后的技术。</p><p>一个高性能的爬虫程序通常被设计为分布式结构：区别于运行在特定机器上的单个程序，它会在云上的多台机器上运行多个实例，这样的结构带来更好的任务再分配、更好的性能和更大的带宽。（ps:这里使用吞吐量会不会更合适？）</p><p>但是分布式软件并不是没有瑕疵的：一些因素可能会给你的的程序带来额外的延迟、或者可能会降低你的程序的性能，比如说网络的延迟、同步的问题、缺乏设计的通信协议等等。</p><p>为了追求更好的性能，一个分布式的爬虫应该有足够良好的设计：这让消除许多性能上的瓶颈成为可能，就像法国的海军上将Olivier Lajous说的：</p><pre><code>一个链子的强度取决于最薄弱的一环。</code></pre><h2 id="Trandoshan：一个暗网爬虫"><a href="#Trandoshan：一个暗网爬虫" class="headerlink" title="Trandoshan：一个暗网爬虫"></a>Trandoshan：一个暗网爬虫</h2><p>你可能知道很多非常成功的网络爬虫，比如Google。所以我并不想去做一个同样的东西。我当下想要去构建一个基于暗网的爬虫。（ps:trandoshan是星球大战中的狩猎种族）</p><h3 id="什么是暗网？"><a href="#什么是暗网？" class="headerlink" title="什么是暗网？"></a>什么是暗网？</h3><p>没必要去使用很多术语去形容什么是暗网，要写起暗网的来龙去脉可能要新建一篇文章。</p><p>Web是由三层结构组成的，我们可以将其视为一座冰山：</p><ul><li>第一层：表面网络，或者说是净网是我们每天最常接触的网络的那部分。它们被一些炙手可热的网络爬虫比如Google，Qwant，Duckduckgo等等所定位。</li><li>第二层：更深层次的网络，是由一些无法被定位的网页组成的，这意味着你是用搜索引擎都找不到这些网页，但是你却可以直接使用URL和IP地址来访问这些页面。</li><li>第三层：暗网，这是一类你是用浏览器都无法访问到的网页。你需要使用特定的应用程序或者特定的代理才可以访问。最出名的暗网是隐藏在洋葱头网络下的。你可以使用以.onion结尾的URL去访问它们。</li></ul><h3 id="Trandoshan是如何设计的？"><a href="#Trandoshan是如何设计的？" class="headerlink" title="Trandoshan是如何设计的？"></a>Trandoshan是如何设计的？</h3><p><img src="https://creekorful.me/content/images/2019/09/Trandoshan-1.png" alt></p><p>在分别讲解这些进程的作用之前，我觉得首先要讲清楚的是这些进程之间如何通信。</p><p>进程间通讯（Inter Process Communication, IPC），主要是通过使用一个基于生产者/消费者模式的名为<a href="https://nats.io/" target="_blank" rel="noopener">NATS</a>（图中黄色的线）的通讯协议，每个在NATS中的消息都有一个主题（就像邮件里的那样），支持其他进程去识别并且仅读取它们想要读取的消息。NATS支持扩展：比如可以支持十个爬虫进程从一个消息服务器并发的读取消息（许多实例可以同时运行而不出任何bug）并因此可以提升性能。</p><p>Trandoshan分为四个主要的进程：</p><ul><li>爬虫：用于爬取页面的进程：它们从NATS读取将要爬取的页面的URL（消息的主题是”todoUrls”），爬取它，并且获取整个页面中显示的全部URL，并且发送这些URL到NATS中（这些消息的主题是”crawledUrls”），而页面的内容则以主题”content”发送到NATS。</li><li>调度器：这个进程用于检查URL：它读取主题为”crawledUrls”，检查其是否是已经爬取过的URL，如果还没有被爬取过，则将URL以主题”todoUrls”发送到NATS。</li><li>持久器：这个进程用于网页内容的构建：它读取以”content”为主题的消息，并且存储到非关系型数据库中（MongoDB）</li><li>接口：给其他进程开放用于聚合数据的进程。比如开放给调度器的用于确定URL是否被爬取过的接口，相比于调度器直接和数据库进行交互，更倾向于调度器和API们交互。</li></ul><p>不同的进程们都是使用Go语言进行编写的：因为它的性能很好（可以被编译为二进制文件）并且有很多的库。Go是用来构建高性能的分布式系统的完美解决方案。</p><p>Trandoshan的源码在github的这里：<a href="https://github.com/trandoshan-io" target="_blank" rel="noopener">https://github.com/trandoshan-io</a></p><h3 id="怎么运行Trandoshan？"><a href="#怎么运行Trandoshan？" class="headerlink" title="怎么运行Trandoshan？"></a>怎么运行Trandoshan？</h3><p>就像之前讲过的一样，Trandoshan被设计为运行在一个分布式的系统上，并且可以使用Docker的镜像来运行，这对于云来说是很好的支持。事实上我整理了一个存储着所有部署需要的配置文件的仓库，可以用于部署Trandoshan实例在K8S上。这些文件在这里：<a href="https://github.com/trandoshan-io/k8s" target="_blank" rel="noopener">https://github.com/trandoshan-io/k8s</a> 并且docker的镜像也都上传到了<a href="https://hub.docker.com/u/trandoshanio" target="_blank" rel="noopener">Docker Hub</a>。</p><p>如果你拥有一个配置成功的kubectl（K8S的控制程序），你可以通过一条简单的命令部署Trandoshan：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bootstrap.sh</span><br></pre></td></tr></table></figure><p>不然的话你可以使用Docker和docker-compose在本地运行Trandoshan。在<a href="https://github.com/trandoshan-io/trandoshan-parent" target="_blank" rel="noopener">trandoshan-parent</a>这个仓库中有构建文件和shell脚本，所以你可以使用以下命令来运行这个应用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./deploy.sh</span><br></pre></td></tr></table></figure><h3 id="如何使用Trandoshan？"><a href="#如何使用Trandoshan？" class="headerlink" title="如何使用Trandoshan？"></a>如何使用Trandoshan？</h3><p>现在有一个小型的Angular应用去检索定位内容。这个页面使用了API进程去完成对于数据库的检索工作。</p><p><img src="https://creekorful.me/content/images/2019/09/Screenshot-from-2019-09-22-17-09-49.png" alt></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>这就是整个介绍了，Trandoshan已经是一个完整的产品了，但是还有很多优化工作需要去完成。由于这是一个开源项目，每个人都可以通过pull request的方式来对它进行贡献。</p><p>愿你在这条码路上走的开心！Happy hacking！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构建一个高性能现代网络爬虫&quot;&gt;&lt;a href=&quot;#构建一个高性能现代网络爬虫&quot; class=&quot;headerlink&quot; title=&quot;构建一个高性能现代网络爬虫&quot;&gt;&lt;/a&gt;构建一个高性能现代网络爬虫&lt;/h1&gt;&lt;p&gt;PS:本文为&lt;a href=&quot;https://cre
      
    
    </summary>
    
    
    
      <category term="Go" scheme="http://shiinaorez.github.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>《Concurrency in Go》阅读笔记 -- 第三章：Go语言并发组件</title>
    <link href="http://shiinaorez.github.com/2019/06/14/concurrency-in-go-3/"/>
    <id>http://shiinaorez.github.com/2019/06/14/concurrency-in-go-3/</id>
    <published>2019-06-13T19:27:06.000Z</published>
    <updated>2019-06-13T19:38:41.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Concurrency-in-Go》"><a href="#《Concurrency-in-Go》" class="headerlink" title="《Concurrency in Go》"></a>《Concurrency in Go》</h1><hr><blockquote><p>本章节从goroutine入手，讲解go语言的各种并发原语。在讲解完goroutine之后，对于传统的内存同步访问的并发原语：sync包中的Mutex，RWMutex，Cond，Once，WaitGroup，Pool等进行了分析。在此之后着重讲了go语言的另一大特色：channel。在最后，讲解了如何结合channel的语法：select语句。</p></blockquote><blockquote><p>插一句题外话：这本书的中文版本的翻译就是一坨屎。</p></blockquote><hr><h2 id="Chapter-3：Go’s-Concurrency-Building-Blocks-Go-语言并发组件"><a href="#Chapter-3：Go’s-Concurrency-Building-Blocks-Go-语言并发组件" class="headerlink" title="Chapter 3：Go’s Concurrency Building Blocks Go 语言并发组件"></a>Chapter 3：Go’s Concurrency Building Blocks Go 语言并发组件</h2><hr><h3 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h3><p>goroutine是Golang中最基本的组织单位之一，每个go语言的程序都至少有一个goroutine：main goroutine，它在进程开始时自动创建并且启动。</p><h4 id="什么是goroutine？"><a href="#什么是goroutine？" class="headerlink" title="什么是goroutine？"></a>什么是goroutine？</h4><p>简单的说：goroutine是一个并发的函数，可以和别的代码块同时运行（不一定是并行的）。</p><p>至于如何使用<code>go</code>关键字来简单的创建一个goroutine，就不多讲了，看到这个博客的人估计没那么傻。</p><p>golang中的goroutine是这个世界上独一无二的东西。它不是OS线程，也不是绿色线程（由语言运行时管理的线程）。有些中文的翻译为轻量线程，但是事实上<code>goroutine is a coroutine</code>，也就是说goroutine是一个协程。协程是一种非抢占式的特殊线程（进程和线程是抢占式的）。协程不能被中断，但是协程尤多个允许暂停和重新进入的点。</p><h4 id="goroutine的独到之处（和普通协程的区别）"><a href="#goroutine的独到之处（和普通协程的区别）" class="headerlink" title="goroutine的独到之处（和普通协程的区别）"></a>goroutine的独到之处（和普通协程的区别）</h4><p>goroutine的独到之处在于它们与<strong>golang的运行环境</strong>的深度集成。（原文是：<strong>What makes goroutines unique to Go are their deep integration with Go’s runtime.</strong> 这里的所谓<code>golang的运行环境其实是特指的golang的runtime</code> | 在中文翻译中为：它们与Go语言运行时的深度集成，这根本就不通顺嘛！）</p><p>goroutine定义了自己的暂停的方法和再切入的点。Go语言的runtime会观察goroutine的运行时的行为，并且在阻塞的时候自动挂起它们，然后在不被阻塞的时候再恢复。 <strong>在golang的runtime和goroutine的逻辑之间有一种优雅的伙伴一样的关系。</strong></p><h4 id="goroutine怎么实现并发"><a href="#goroutine怎么实现并发" class="headerlink" title="goroutine怎么实现并发"></a>goroutine怎么实现并发</h4><p>协程（coroutine）和goroutine都是隐式并发结构，这说明并发并不是协程的属性：必须同时托管多个协程，并且给每个协程一个执行的机会。</p><p>Golang的主机托管机制是一个M：N调度器，主要机制就是将M个由程序管理的线程映射到N个OS线程。而M：N调度器可以单独写一个博客了，这里就不再细说。</p><p>Golang遵循一个称为<code>fork-join</code>的并发模型。</p><ul><li>fork是指在程序运行中的任意一点，它可以将执行的子分支和父节点同时运行。</li><li>join这个词是指的是在将来的某个时候，这个并发的执行分支将会合并在一起。</li></ul><p><img src="https://i.loli.net/2019/06/11/5cff86dd04d0395892.png" alt></p><p>在fork-join模型中，掌握join的点是至关重要的，因为join点是保证程序的正确性和<strong>消除竞争条件</strong>的关键。而控制join点的关键技术是WaitGroup。</p><h4 id="goroutine中闭包运行的情况"><a href="#goroutine中闭包运行的情况" class="headerlink" title="goroutine中闭包运行的情况"></a>goroutine中闭包运行的情况</h4><p>我们在快速创建goroutine的时候往往会选择使用匿名函数来创建，这就牵扯到了闭包中变量的引用问题：<strong>闭包可以从创建它们的作用域中获取变量，那么当这个闭包运行的时候，调用这些变量的方式是副本还是引用呢？</strong></p><p>举个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">salutation := <span class="string">"hello"</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    salution = <span class="string">"welcome"</span></span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"Out:"</span>, salutation)</span><br></pre></td></tr></table></figure><p>我的得到的输出是：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Out: welcome</span><br></pre></td></tr></table></figure></p><p>事实证明，goroutine在它们所创建的相同地址空间内执行。<br>从另一个角度再进行一个实验：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>&#125; &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(salutation)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>这个程序我们期望得到的结果是：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">greetings</span><br><span class="line">good day</span><br></pre></td></tr></table></figure><p>以上的所有可能的排列组合，因为我们都知道并发所带来的竞争条件产生的影响，但是输出却让我们大吃一惊：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">good day</span><br><span class="line">good day</span><br><span class="line">good day</span><br></pre></td></tr></table></figure><p>当大家看到输出的时候应该已经明白了究竟是怎么回事：<strong>在输出之前，salutation就已经完成了迭代。</strong>    </p><p>但是值得注意的一点是，既然迭代已经结束，为什么还能使用salutation的引用呢？这个就和golang的GC有关，golang的GC会小心的把salutation的引用从内存转移到堆，以便能够继续使用。</p><p>所以正确的程序应该这样编写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> _, salutation := <span class="keyword">range</span> []<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"greetings"</span>, <span class="string">"good day"</span>&#125; &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(salutation <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(salutation)</span><br><span class="line">    &#125;(saluation)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>也就是传入数据的副本。</p><p>由于所有的goroutine都在相同的地址空间中运行，而且只有简单的宿主函数，所有使用goroutine编写并发的任务是非常的自然的，golang的编译器很好的处理了内存中的变量，这样goroutine就不会意外的访问被释放的内存，这使得开发人员可以专注于它们的问题是如何被解决的，而不需要去消耗更多精力来管理内存。</p><p>但是golang带来的这些好处也付出了一些代价，由于多个goroutine运行在同一个地址空间，所以我们仍然需要担心同步问题。解决问题的方法：sync包和channel我们会在后面的小节进行讨论。</p><h4 id="goroutine有多么的轻量级"><a href="#goroutine有多么的轻量级" class="headerlink" title="goroutine有多么的轻量级"></a>goroutine有多么的轻量级</h4><p>以下是摘自Go Programming Language FAQ中的一段话。<br><img src="https://i.loli.net/2019/06/11/5cffa2e8adeaa61523.png" alt="在这里插入图片描述"><br>这段话很夸张的说出：<strong>在同一个地址空间中创建成千上万的goroutine是可行的。</strong></p><p>这是吹牛逼吧！怎么可能！</p><p>但是goroutine就是这么轻量，一个goroutine只有几千个字节，这完全是ok的。</p><p>但是当进程多了起来，一个问题将明显的影响着程序的性能：<strong>上下文之间的切换</strong>。当进程之间来回不断的切换的时候，保存现场和恢复现场的工作显得格外耗时，那么goroutine这么多，在它们之间的切换应该也相当耗时吧？</p><p>但是并不！goroutine之间的切换速度是OS线程切换速度的8%！</p><p>太轻了，实在是太轻了。goroutine的使用代价如此的小让我们能够放手的去用goroutine解决并发问题。</p><hr><h3 id="Package-sync"><a href="#Package-sync" class="headerlink" title="Package sync"></a>Package <code>sync</code></h3><blockquote><p>sync包包含了对于低级别内存访问同步最有用的并发原语。很简单，很基础。</p></blockquote><h4 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h4><p>当你不关心并发操作的结果，或者你又其他的方法能够收集它们的结果的时候。WaitGroup是等待一组并发操作完成的好办法。</p><p>你可以将WaitGroup视为一个并发安全的计数器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Add</span><span class="params">(delta <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">// <span class="title">Add</span> 方法增加计数器的增量。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// 调用<span class="title">Done</span>方法来对计数器进行递减。</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(wg *WaitGroup)</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">// <span class="title">Wait</span>方法会阻塞，直至计数器为0.</span></span><br></pre></td></tr></table></figure><p>使用WaitGroup的时候需要注意的是：Add方法的调用应该是在跟踪的goroutine之外调用的。如以下程序为例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的示例</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// wg.Add(1) 如果在这里调用wg.Add()会让程序直接结束。因为竞争条件。</span></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fmt.Println(<span class="string">"Hello"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><h4 id="Mutex-amp-RWMutex"><a href="#Mutex-amp-RWMutex" class="headerlink" title="Mutex &amp; RWMutex"></a>Mutex &amp; RWMutex</h4><p>锁，这一节讲的就是锁。不管是在数据库中还是在一些传统的并发处理中，锁往往都是我们最常见的方式或者方法。而在<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Locker</span><br><span class="line">`sync`包中有一个锁接口，具体定义如下。</span><br><span class="line">```go</span><br><span class="line">type Locker interface &#123;</span><br><span class="line">    Lock()</span><br><span class="line">    Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="Mutex-互斥锁"><a href="#Mutex-互斥锁" class="headerlink" title="Mutex 互斥锁"></a>Mutex 互斥锁</h5><p>互斥是保护程序中临界区的一种方式，临界区是程序中需要独占访问共享资源的区域。<code>Mutex</code>提供了一种安全的方式来表示对这些共享资源的<strong>独占访问</strong>。</p><blockquote><p>为了使用一个资源，<code>channel</code>通过通信的方式来共享内存，而<code>Mutex</code>通过开发人员的<strong>约定</strong>来同步访问共享内存。</p></blockquote><p>在使用的时候，往往会将共享资源和互斥锁绑定在一起：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NewResource <span class="keyword">struct</span> &#123;</span><br><span class="line">    Resource []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    Lock     *sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时通过使用<code>sync.Mutex.Lock()</code>方法和<code>sync.Mutex.Unlock()</code>方法来声明对于资源的独占开始和结束。</p><blockquote><p>最好使用 defer关键字来结束独占，否则可能因为panic引发死锁</p></blockquote><p>在此之前我们介绍了原子操作的概念，也就是一个操作的原子性。事实上我们在对于一个资源的独占期间我们绝对不想要被打断，也就是说在对于资源的操作的上下文下，我们对于资源独占期间的操作整体是具有原子性的，而又结合我们之前接触过的所谓<strong>饥饿</strong>的概念，我们知道，我们的临界区应该尽可能的小，也就是我们独占的时间应该尽可能的小。因此一个良好的Mutex的使用应该像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(resource)</span></span> &#123;</span><br><span class="line">    init() <span class="comment">// 和资源无关的操作</span></span><br><span class="line">    resource.Lock.Lock()</span><br><span class="line">    <span class="keyword">defer</span> resource.Lock.Unlock()</span><br><span class="line"></span><br><span class="line">    resource.Operation() <span class="comment">// 对于资源的操作</span></span><br><span class="line">&#125;(resource_1)</span><br></pre></td></tr></table></figure><h5 id="RWMutex-读写互斥锁"><a href="#RWMutex-读写互斥锁" class="headerlink" title="RWMutex 读写互斥锁"></a>RWMutex 读写互斥锁</h5><p>读写锁在概念上和和互斥锁是一样的，但是读写锁让你对于内存有了更多的控制，也就是你可以单独请求一个锁用于读处理，这个情况下你将被授予访问权限。</p><h4 id="cond-条件变量"><a href="#cond-条件变量" class="headerlink" title="cond 条件变量"></a>cond 条件变量</h4><p><img src="https://i.loli.net/2019/06/13/5d0202140b03134769.png" alt="这是cond的截图"><br><code>Cond</code>实现了一个条件变量，是一些正在等待或者声明一个<strong>事件</strong>的goroutine的集合点。</p><p>每一个<code>Cond</code>都有一个相关联的锁，必须在条件改变和调用<code>wait()</code>时进行状态的改变。</p><p>在上述的定义中，有一个重要的概念：<strong>事件</strong>。这里的事件（Event）是指两个或者两个已上的goroutine之间的任意信号，除去这个事件已经发生之外，没有任何的信息能够被我们利用。</p><p>先看一下在不使用<code>cond</code>的时候我们应该怎样检查这个事件是否完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> conditionTrue() == <span class="literal">false</span> &#123;&#125;</span><br><span class="line">then()</span><br></pre></td></tr></table></figure><p>使用一个死循环来检查！这太聪明了！但是这样会消耗你所有的CPU时钟周期！</p><p>因此我们可以定时来检查一下？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> !conditionTrue() &#123;</span><br><span class="line">    time.Sleep(<span class="number">1</span>*time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">then()</span><br></pre></td></tr></table></figure><p>这显然比死循环好多了，但是也是相当低效的行为，而且对于休眠的时间长度也要有所掌控：太长，会人为的降低性能；太短，会不必要地消耗大量的CPU时间。而<code>cond</code>就是为了解决这种问题而生的。</p><p>让我们使用<code>cond</code>来改写之前的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cond := sync.NewCond(&amp;sync.Mutex&#123;&#125;) <span class="comment">// new一个新的cond</span></span><br><span class="line">cond.L.Lock() <span class="comment">// 锁定条件，因为在执行cond.Wait()的时候会自动调用Unlock()</span></span><br><span class="line"><span class="keyword">for</span> !conditionTrue() &#123;</span><br><span class="line">    cond.Wait() <span class="comment">// 开始等待，在另一个goroutine中发送信号来终止等待</span></span><br><span class="line">&#125;</span><br><span class="line">c.L.Unlock() <span class="comment">// 解锁这个条件，而Wait()方法在退出的时候会自动调用Lock()</span></span><br></pre></td></tr></table></figure><p><code>Wait()</code>方法不只是阻塞了goroutine，还挂起了当前的goroutine，允许其他goroutine在OS线程上运行。</p><p><img src="https://i.loli.net/2019/06/13/5d0218176763198286.png" alt="可以看出Wait()中的Lock和Unlock"><br>这里介绍了为什么使用循环来判定，而并非只使用<code>if</code>语句：因为当<code>Wait()</code>第一次返回的时候我们不能认为条件成立了，因此需要循环等待。但是这显然要比之前的两种方法高效多了。</p><p>其他的能够很好的体现的<code>cond</code>的例子，比如分配房间的例子在书中都有讲解，也挺好理解的，这里就不赘述了。</p><h5 id="发送信号的方式：Signal和Broadcast"><a href="#发送信号的方式：Signal和Broadcast" class="headerlink" title="发送信号的方式：Signal和Broadcast"></a>发送信号的方式：Signal和Broadcast</h5><p>golang的runtime会内部维护一个FIFO的goroutine队列，等待接收信号。<code>Signal</code>会发现等待时间最长的goroutine并且通知它，而<code>Broadcast</code>会向所有等待的goroutine发送信号。</p><p>这里的<code>Broadcast</code>提供了一种同时和多个goroutine通信的方式，当然，我们也可以通过<code>channel</code>对信号进行简单的复制，但是使用<code>Broadcast</code>是更加自然且高效的行为。</p><h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><p><code>once</code>，顾名思义就是只执行一次。就很简单。就很简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Only do it once."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    once.Do(function)</span><br><span class="line">&#125; </span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure><p>直觉告诉我们这句话<code>Only do it once.</code>只会输出一次。事实上确实如此。</p><p>这里需要注意的一点是：<code>once</code>只记录自己一共执行了多少个函数，而并非多少个不同的函数。</p><h4 id="Pool-池"><a href="#Pool-池" class="headerlink" title="Pool 池"></a>Pool 池</h4><p><code>Pool</code>是Pool设计模式的并发安全实现。Pool设计模式是一种可以创建和提供可供使用的固定数量的实例或者Pool实例的方法。通常用于约束<strong>创建昂贵</strong>的场景（比如数据库的连接操作）。对于<code>sync.Pool</code>，这种数据类型可以被多个goroutine安全的使用。</p><p><code>Pool</code>的主要的几个方法是：</p><ul><li>使用<code>Get</code>方法来获取一个池中的实例给调用者。如果池中没有则会<code>new</code>一个新的实例出来。</li><li>在使用完毕之后，会调用<code>Put</code>方法把实例还给池。</li></ul><h5 id="为什么使用Pool？"><a href="#为什么使用Pool？" class="headerlink" title="为什么使用Pool？"></a>为什么使用Pool？</h5><p>为什么要使用<code>Pool</code>而不是直接创建一个新的实例呢？这是因为golang有GC，因此实例化的对象会被自动清理。</p><p>另一个原因是，可以使用<code>Pool</code>来尽可能快的将预先分配的对象缓存加载启动。在处理代价昂贵的事务的时候这种模式可以极大的提高性能。</p><blockquote><p>当并发进程需要一个对象，并且处理它的过程会是相当的快速的过程，或者这些对象的构造过程会对内存产生负面的影响，这个时候你最好使用Pool设计模式。</p></blockquote><p>使用<code>Pool</code>时最好注意的几个点：</p><ul><li>当实例化<code>sync.Pool</code>时，使用<code>new</code>方法创建一个成员变量，在调用时会是线程安全的。</li><li>当你收到一个来自<code>Get</code>方法的实例的时候，不需要对接受的对象的状态进行任何的假设判定，因为一定合法的。</li><li>当你使用完成了一个从Pool中取出来的实例的时候，请一定使用<code>Put</code>方法把它放回去，负责你就没有办法复用这个实例了，通常情况之下会使用<code>defer</code>关键字来调用方法。</li></ul><hr><h3 id="channel-信道"><a href="#channel-信道" class="headerlink" title="channel 信道"></a>channel 信道</h3><blockquote><p>正如之前介绍过的CSP中的channel一样，你最好使用golang中的channel来进行goroutine之间的通信。而并非是用于同步内存访问。</p></blockquote><p>channel是一个用于传递信息的管道。信息从一头进，从一头出。</p><h4 id="创建和使用channel"><a href="#创建和使用channel" class="headerlink" title="创建和使用channel"></a>创建和使用channel</h4><p>创建一个channel非常的简单，只是需要指定一下数据的类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStream <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 声明</span></span><br><span class="line">dataStream = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// 实例化</span></span><br></pre></td></tr></table></figure><p>一个普通的channel是双向的，也就是既可以输入数据，也可以读出数据。但是事实上，你也可以使用单向的channel，也就是定义一个channel，只用于发送或者接受数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 一个只用于读取的channel</span></span><br><span class="line"><span class="keyword">var</span> inputStream <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 一个只用于输入的channel</span></span><br></pre></td></tr></table></figure><p>golang在必要的时候会将双向的channel隐式地转换为单向的channel。</p><p>一个简单的小例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stringStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stringStream &lt;-<span class="string">"Hello, channels!"</span></span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&lt;-stringStream)</span><br></pre></td></tr></table></figure><p>这一段程序中，按照我们之前的理解：竞争条件在这里依然存在，也就是在程序退出之前很可能都不会执行goroutine中的内容。但是事实上channel消除了竞争条件。</p><p>这是因为channel的输入和读出在<strong>一定条件下都会让goroutine阻塞</strong>：当channel是空，但是你想要读取数据。或者channel满了你却想输入数据的时候。</p><p>能够阻塞，当然也能导致DeadLock，因此在使用的时候一定要注意。</p><p>关闭一个channel：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(stringStream)</span><br></pre></td></tr></table></figure><p>读出数据的时候可以读出两个值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data, ok := &lt;-stringStream </span><br><span class="line"><span class="comment">// 第一个值是数据值，或者被关闭的通道产生的数据的默认值</span></span><br><span class="line"><span class="comment">// 第二个值是状态值，判断信道的状态是开放还是关闭，开放是true，关闭是false</span></span><br></pre></td></tr></table></figure><p>正因为channel的可以关闭并且有返回值的特性，我们可以使用<code>for-range</code>，并且在channel关闭的时候自动中断循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> stringStream &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="带缓冲的信道-buffered-channel"><a href="#带缓冲的信道-buffered-channel" class="headerlink" title="带缓冲的信道 buffered channel"></a>带缓冲的信道 buffered channel</h4><p>所谓<code>buffered channel</code>就是一个有缓冲容量的信道，我们在之前看到的channel其实就是缓冲容量为0的信道。我们在声明一个新的信道的时候就可以指定缓冲容量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataStream := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>带缓冲的channel是一个内存中的FIFO队列，用于并发进程之间的通信。</p><p>两个比较生动形象的图：</p><p><img src="https://i.loli.net/2019/06/13/5d023f66d97b699629.png" alt><br><img src="https://i.loli.net/2019/06/13/5d023fa85203120841.png" alt></p><h4 id="channel上的操作和相应的结果"><a href="#channel上的操作和相应的结果" class="headerlink" title="channel上的操作和相应的结果"></a>channel上的操作和相应的结果</h4><table><thead><tr><th>操作</th><th>Channel的状态</th><th>结果</th></tr></thead><tbody><tr><td>Read</td><td>nil</td><td>阻塞</td></tr><tr><td></td><td>打开且非空</td><td>输出值</td></tr><tr><td></td><td>打开但是空</td><td>阻塞</td></tr><tr><td></td><td>关闭</td><td>&lt;默认值&gt;，false</td></tr><tr><td></td><td>只写</td><td>编译错误</td></tr><tr><td>Write</td><td>nil</td><td>阻塞</td></tr><tr><td></td><td>打开且满</td><td>阻塞</td></tr><tr><td></td><td>打开且不满</td><td>写入值</td></tr><tr><td></td><td>关闭</td><td>panic</td></tr><tr><td></td><td>只读</td><td>编译错误</td></tr><tr><td>close</td><td>nil</td><td>panic</td></tr><tr><td></td><td>打开且非空</td><td>关闭channel；读取成功，直到信道内值耗尽，然后读取产生值的默认值</td></tr><tr><td></td><td>打开但是空</td><td>关闭channel；读到生产者的默认值</td></tr><tr><td></td><td>关闭的</td><td>panic</td></tr><tr><td></td><td>只读</td><td>编译错误</td></tr></tbody></table><h4 id="使用channel的基本素养"><a href="#使用channel的基本素养" class="headerlink" title="使用channel的基本素养"></a>使用channel的基本素养</h4><p>所谓<strong>基本素养</strong>，其实就是规范使用channel的方法，从而规避死锁和panic的风险。</p><p>一个拥有channel的goroutine应该有以下操作：</p><ul><li><ol><li>实例化channel</li></ol></li><li><ol start="2"><li>执行写操作，或者将channel的所有权传递给其他goroutine</li></ol></li><li><ol start="3"><li>关闭channel</li></ol></li><li><ol start="4"><li>将1-3项封装好，并且通过一个只读channel将其暴露出来</li></ol></li></ul><h3 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h3><blockquote><p>channel是goroutine之间的粘合剂，而select语句则是channel之间的粘合剂。</p></blockquote><p>如何使用select语句呢？下面是一个简单的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chan1, chan2 &lt;-<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> chan3 <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> &lt;-chan2:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">case</span> c3&lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和switch语句是很像，但是select语句中的case语句没有测试顺序，即使没有满足任何条件，执行也不会失败。而且一个很大的特性是：golang运行时会将一组case语句中执行伪随机选择。</p><p>使用伪随机选择的原因是，golang无法解析select语句的意图，也就是说，它不能推断出问题空间，或者说为什么将一组channel组合在一个select语句中。在这种情况下，最好的选择就是平均情况下运行良好。</p><h4 id="为select语句设置超时时间"><a href="#为select语句设置超时时间" class="headerlink" title="为select语句设置超时时间"></a>为select语句设置超时时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channel:</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">1</span>*time.Second):</span><br><span class="line">    <span class="comment">// ...超时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="select语句中的default"><a href="#select语句中的default" class="headerlink" title="select语句中的default"></a>select语句中的default</h4><p>在select中也存在default语句，执行的条件是全部的channel都是阻塞的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> channel &lt;-<span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-channel:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// ...几乎是瞬间执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用for-select结构在等待同时工作"><a href="#使用for-select结构在等待同时工作" class="headerlink" title="使用for-select结构在等待同时工作"></a>使用for-select结构在等待同时工作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> channel:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...工作语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="永远阻塞的语句也永远最简单"><a href="#永远阻塞的语句也永远最简单" class="headerlink" title="永远阻塞的语句也永远最简单"></a>永远阻塞的语句也永远最简单</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个语句将永远阻塞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《Concurrency-in-Go》&quot;&gt;&lt;a href=&quot;#《Concurrency-in-Go》&quot; class=&quot;headerlink&quot; title=&quot;《Concurrency in Go》&quot;&gt;&lt;/a&gt;《Concurrency in Go》&lt;/h1&gt;&lt;hr&gt;

      
    
    </summary>
    
    
    
      <category term="Concurrency In Go" scheme="http://shiinaorez.github.com/tags/Concurrency-In-Go/"/>
    
  </entry>
  
  <entry>
    <title>《Concurrency in Go》阅读笔记 -- 第二章：对你的代码建模，通信顺序进程</title>
    <link href="http://shiinaorez.github.com/2019/05/31/concurrency-in-go-2/"/>
    <id>http://shiinaorez.github.com/2019/05/31/concurrency-in-go-2/</id>
    <published>2019-05-30T16:05:46.000Z</published>
    <updated>2019-05-30T16:08:26.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Concurrency-in-Go》"><a href="#《Concurrency-in-Go》" class="headerlink" title="《Concurrency in Go》"></a>《Concurrency in Go》</h1><hr><blockquote><p>并发和并行的区别傻傻分不清？第二章从大众最常见的误区：并发和并行的区别，进行切入。从而牵扯出了对于并发代码的建模问题。从CSP入手讲解了go语言的好处和golang的并发哲学。</p></blockquote><hr><h2 id="Chapter-2：Modeling-Your-Code-Communicating-Sequential-Processes-对你的代码建模：通信顺序进程（CSP）"><a href="#Chapter-2：Modeling-Your-Code-Communicating-Sequential-Processes-对你的代码建模：通信顺序进程（CSP）" class="headerlink" title="Chapter 2：Modeling Your Code: Communicating Sequential Processes 对你的代码建模：通信顺序进程（CSP）"></a>Chapter 2：Modeling Your Code: Communicating Sequential Processes 对你的代码建模：通信顺序进程（CSP）</h2><hr><h3 id="1-Concurrency-and-Parallelism-并发与并行"><a href="#1-Concurrency-and-Parallelism-并发与并行" class="headerlink" title="1 Concurrency and Parallelism 并发与并行"></a>1 Concurrency and Parallelism 并发与并行</h3><h3 id="1-1-The-Difference-Between-Concurrency-and-Parallelism-并发与并行的区别"><a href="#1-1-The-Difference-Between-Concurrency-and-Parallelism-并发与并行的区别" class="headerlink" title="1.1 The Difference Between Concurrency and Parallelism 并发与并行的区别"></a>1.1 The Difference Between Concurrency and Parallelism 并发与并行的区别</h3><p>并发和并行，对于普通人而言总是忽略二者之间的区别，经常被混用于表达“某种和其他事物同时运行的事务”。但是这二者的区别对于一个开发者而言至关重要：最起码在讨论代码的时候你应该使用并发这个词。</p><p><strong>并发和并行的区别在你对代码进行建模的时候是一个非常强力的抽象。</strong></p><p>首先从一个简单的陈述句，我们来看清其中的区别：</p><blockquote><p>并发属于代码，而并行属于一个运行中的程序。</p></blockquote><p>直观的感受上人们很容易忽略程序真正运行时的情况，这都是因为高级程序设计语言为我们封装了很多，以至于我们只去考虑我们的代码是否是并发的。而并非去考虑我写出的程序是否真正是并行执行的。</p><p>一个人写出并发的代码，但是这个并发的代码所构建的程序是否能够真正的并行执行却是一个问题：比如在只有一个处理器的时候。</p><p>我们在第一章中说出过多核处理器的由来。但是当只有一个核心的时候我们的并发代码还能够正常的执行吗？</p><p>当然可以！我们的代码像我们想象的一样执行了起来，而且看上去比起串行确实有效率的提升。这是因为多个线程在复用同一个处理器，这一个处理器把自己的时间周期分了又分，好让每一个线程都有计算的时间。<strong>但是事实上这些计算过程不是同时执行的！</strong></p><p>在这里你大概能体会到一点并发和并行的区别了，那么趁热打铁再说几句话：</p><blockquote><p>首先我们没有编写并行的代码，只有我们希望可以并行执行的并发代码。<br>另外，并行是我们的程序运行时的属性，而不是我们代码的属性。</p></blockquote><p>还有一个非常有意思的事情是：<strong>并行也是依赖上下文的。</strong></p><p>在第一章的时候我们提到了判断一个操作的原子性时需要依赖上下文，在判断并行的时候我们也应该依赖这种思想。现在不妨思考一个问题：为什么大多数人会搞混并发和并行？<strong>就是因为在运行并发代码的时候他们也同时认为程序是在并行计算的！</strong> 因为考虑问题的上下文不同。</p><p>编写并发代码层面的人，假设有两个分别消耗x和y时间的操作。如果被认为是并行执行的上下文大于等于x+y，那么就可以认为这两个操作是并行执行的。反之则认为不是的。因为可以把一个上下文看做一个单位时间，既然在一个单位时间里完成了两个操作，那么为什么不认为是并行执行的呢？</p><h3 id="1-2-所带来的问题"><a href="#1-2-所带来的问题" class="headerlink" title="1.2 所带来的问题"></a>1.2 所带来的问题</h3><p>由以上可以看到：进程是维持并发的关键。但是进程的出现又带来了很多的问题：对于资源的权限，进程之间的干扰等等。虽然在现有的操作系统和进程的边界能帮助我们减轻很大一部分考虑逻辑正确性的压力，但是对于进程的控制是必不可少的。</p><blockquote><p> 事实上随着我们抽象栈的深入，如何正确的对事物进行建模变得越来越让人难以理解，对我们来说越来越重要。换言之，编写正确的并发逻辑越来越难，越需要我们将很简单的并发原语组合起来使用。</p></blockquote><p>在golang之前的语言，大部分的主流编程语言都有一系列的抽象层。然后写一大堆天花乱坠的代码来维护你需要调用的线程。但是golang不一样（golang简直就是小天使</p><p>golang提供了著名的<strong>goroutine和channel</strong>，这对于开发者而言简直就是救星：我们几乎不在操作系统的线程层面考虑我们的问题了，取而代之的是，我们对于事物站在goroutine和channel的层面来进行思考，偶尔站在共享内存的角度思考（这也就是golang的并发哲学）。</p><p>golang中的goroutine和channel从何而来呢？<strong>源于1978年Charles Antony Richard Hoare撰写的一篇论文。</strong></p><hr><h3 id="2-Communicating-Sequential-Processes，CSP"><a href="#2-Communicating-Sequential-Processes，CSP" class="headerlink" title="2 Communicating Sequential Processes，CSP"></a>2 Communicating Sequential Processes，CSP</h3><h3 id="2-1-什么是CSP？"><a href="#2-1-什么是CSP？" class="headerlink" title="2.1 什么是CSP？"></a>2.1 什么是CSP？</h3><p>在许多和golang有关的讨论中，CSP经常被赞美成golang成功的原因以及并发编程的“万能钥匙”。但是对于CSP的具体细节却又不求甚解，这一小节就介绍了CSP的相关知识。</p><p><strong>Communicating Sequential Processes，CSP。中文是通信顺序进程。是由Antony Hoare在1978年提出的概念。</strong></p><p>在1978年，大部分关于如何架构程序的研究都是针对编写顺序代码的方法：goto语句的使用正在被讨论，面向对象范型正在成为编程的基石，而并发并没有被给予充分的思考。而霍尔同志这个时候意识到要纠正这个现象，于是在以CSP为题的论文中提出了CSP的概念。</p><p>Hoare认为输入与输出是两个被忽略的编程原语，尤其是在并发的代码中。于是在论文中提出了使用进程间通信来使对于线程的操作以顺序形式编写的语言：CSP，这个时候还只是一个存在于论文中的编程语言。</p><p>Hoare的CSP语言中包含了用于建模输入和输出的原语。并且Hoare开创性地将进程这个概念运用到任何包含<strong>需要输入来运行</strong>且<strong>产生</strong>其他进程<strong>将会消费的输出</strong>的<strong>逻辑片段</strong>。</p><p>CSP的原语在这里不再一一赘述，但是这和golang中的channel的相似性是显而易见的（也太相似了吧！）。为了能够使进程之间安全的通信，Hoare花了很大的力气来优化他的输入输出原语。</p><p>在这之后，Hoare花了六年的时间来提炼CSP的想法为“进程微积分”的东西。进程微积分是一种对于并发系统进行数学化建模的方式，并且提供了代数法则来进行这些系统的变换来分析它们不同的属性。</p><p><strong>经过经验的判断，Hoare对于并发的建议显然是正确的，但是在golang发布之前，很少有语言能够真正的为这些原语提供支持。golang是最早将CSP的原则纳入其核心的语言之一，并将这种编程风格引入到大众中。它的成功也使得其他语言尝试添加这些原语。</strong></p><hr><h3 id="3-How-This-Helps-You-这将如何帮助你"><a href="#3-How-This-Helps-You-这将如何帮助你" class="headerlink" title="3 How This Helps You 这将如何帮助你"></a>3 How This Helps You 这将如何帮助你</h3><p>在之前的讨论中，我们发现了一件事情：golang的并发风格和其他语言为何有如此大的不同？</p><p>通常来说，一种语言会将他们的抽象链结束在系统线程和内存访问同步的层级。golang则采用了一个不同的路线，并且使用goroutine和channel来代替这些概念。</p><p>goroutine把我们从必须按照并行的方式思考中解放出来，作为替代，它允许我们以更加自然的等级对问题进行建模。如果对于一个问题，我们需要对这个并行问题进行建模。如果使用以前的方式进行思考，你会考虑以下问题：</p><ul><li>我的语言原生支持线程吗？还是我需要导入一个新的库？</li><li>我的进程限制边界应该是什么？</li><li>线程在操作系统中的重量级有多高？</li><li>我的程序需要运行的操作系统处理这些线程的时候有什么不同？</li><li>我需要创建一个工作线程池来承载创建的线程，该如何找到最佳的线程池大小？</li></ul><p><strong>这太恶心了，而且你思考了半天却很可能和你原本的问题一点边都不搭！！！！</strong></p><p>我们对于原本问题的抽象的过程由于这些编程语言中并发原语的缺失而变得困难起来。但是这个世界上无数的优秀的程序员的不懈努力使得即使是如此的复杂还是可以开发许多并发的代码。但是当一种更为自然且简单的方式出现的时候我们会怎么想呢？</p><p><strong>golang中的goroutine和channel让我们对于问题进行的思考自然的直接映射为如何使用golang进行编程。</strong></p><p>golang给我们的性能的保证让我们能够放心大胆的使用goroutine：goroutine是很轻量级的，我们通常情况下并不需要为创建新的goroutine所带来的代价而担心。</p><p>建立在抽象并行问题的复杂性的基础之上，几乎每一种语言都有专门的框架来支持开发者们简单的进行开发。但是毕竟是未能从根本上使得考虑问题的方式变得更加的自然和合理。<br>别人撰写的框架时所遇到的复杂问题并未被隐藏，它依然存在，而这种复杂性的累加是滋生bug的温床。</p><p><strong>显然对于问题更加自然和合理的抽象更好，对吧？</strong></p><p>对于一个问题能够更加自然的进行抽象能让你提高将问题建模为并发方式的比例提高了，能够在更细的颗粒度上编写并发代码，从而提高程序的运行效率。</p><p>不仅仅是goroutine，channel和select语句等等也是golang诸多并发拼图中的一块，以后会详细讲解各种用法。</p><hr><h3 id="4-Go’s-Philosophy-on-Concurrency-Go语言的并发哲学"><a href="#4-Go’s-Philosophy-on-Concurrency-Go语言的并发哲学" class="headerlink" title="4 Go’s Philosophy on Concurrency Go语言的并发哲学"></a>4 Go’s Philosophy on Concurrency Go语言的并发哲学</h3><blockquote><p>CSP 一直都是golang设计的重要组成部分</p></blockquote><p>但是如果你想要玩儿内存访问同步，其实也ok，golang中的sync而已满足你的需求。虽然有很多选择对于开发者来说很棒。但是对于golang的初学者却总是抱有一个疑惑：为什么还有支持内存访问同步？使用CSP样式编写程序不应该是golang编写并发代码的唯一方式吗？</p><p>在sync包中这样写到：</p><blockquote><p>sync包提供了基本的同步单元，比如互斥锁。除了Once类型和WaitGroup类型以外，大部分都是适用于低水平程序线程，对于高水平的同步，使用channel通信会更好一些。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190522173525333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>而在Go语言的FAQ中，也有如下陈述：</p><blockquote><p>为了尊重mutex，sync包实现了mutex，但是我们希望Go语言的编程风格将会激励人们尝试更高等级的技巧。尤其是如何去构建你的程序，以便一次只有一个goroutine负责某个特定的数据。<br>不要通过共享内存来进行通信。相反，通过通信来共享内存。有数不清的关于Go语言核心团队的文章，讲座和访谈，相对于使用像sync.Mutex这样的原语，他们更加拥护CSP。</p></blockquote><p>那么现在你就懵逼了，既然不推荐使用为什么还要公开？直接都用channel不ok吗？？？</p><blockquote><p>”使用最好描述和最简单的那个方式。“</p></blockquote><p>何时应该使用锁，而何时又应该使用channel。对于不同的问题会有不同的答案。而如何判断呢？书中给出了一个决策树。</p><p><img src="https://img-blog.csdnimg.cn/20190522174431820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>Go语言的并发哲学可以这样总结：</p><blockquote><p>追求简洁，尽可能使用channel，并且认为goroutine的使用是没有成本的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《Concurrency-in-Go》&quot;&gt;&lt;a href=&quot;#《Concurrency-in-Go》&quot; class=&quot;headerlink&quot; title=&quot;《Concurrency in Go》&quot;&gt;&lt;/a&gt;《Concurrency in Go》&lt;/h1&gt;&lt;hr&gt;

      
    
    </summary>
    
    
    
      <category term="Concurrency in Go" scheme="http://shiinaorez.github.com/tags/Concurrency-in-Go/"/>
    
  </entry>
  
  <entry>
    <title>《Concurrency in Go》阅读笔记 -- 第一章：并发概述</title>
    <link href="http://shiinaorez.github.com/2019/05/13/concurrency-in-go-1/"/>
    <id>http://shiinaorez.github.com/2019/05/13/concurrency-in-go-1/</id>
    <published>2019-05-13T09:34:01.000Z</published>
    <updated>2019-05-13T09:35:29.706Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《Concurrency-in-Go》"><a href="#《Concurrency-in-Go》" class="headerlink" title="《Concurrency in Go》"></a>《Concurrency in Go》</h1><hr><blockquote><p>Golang是一门静态的，强类型的，高并发的语言，而本书会聚焦在高并发的方面。第一章则从并发的基本内容讲起，大致包括几个方面：</p><ul><li>什么是并发？</li><li>并发为什么困难？</li><li>并发为什么值得研究？</li></ul></blockquote><hr><h2 id="Chapter-1：An-Introduction-to-Concurrency-并发概述"><a href="#Chapter-1：An-Introduction-to-Concurrency-并发概述" class="headerlink" title="Chapter 1：An Introduction to Concurrency 并发概述"></a>Chapter 1：An Introduction to Concurrency 并发概述</h2><hr><h3 id="1-从摩尔定律入手，讨论并发从何而来"><a href="#1-从摩尔定律入手，讨论并发从何而来" class="headerlink" title="1 从摩尔定律入手，讨论并发从何而来"></a>1 从摩尔定律入手，讨论并发从何而来</h3><p>摩尔定律的内容是众所周知的，大概就是集成电路上的晶体管的数量每两年就会翻一番。</p><p>这个定律的起因在于，人类迫切地需要提升单位空间的运算能力，因此穷极一切地去努力提升运算能力。而提升运算能力这一需求又源于当今世界上的存储能力和数据产生量的提高。</p><p>但是摩尔定律所预估的速度正在逐步放缓，除非在一段时间以内人类的基础技术能有质的改变。而在这个条件之下应运而生的产物便是：多核处理器。</p><p>以多个核心来处理来处理和解决问题，效率相比起以往肯定是提高了的，尤其在问题可以由各个独立的程序构成而不互相影响的情况下更能有所体现，但是<strong>Gene Amdhl</strong>提出了一条定律:</p><blockquote><p>并行计算的收益的限制取决于有多少程序必须以顺序的方式编写。</p></blockquote><p>也就是说并行计算提升的效率取决于能够<strong>独立执行</strong>的程序。</p><p>云计算，现在的时代的热词。它的思想在时代思潮中根深蒂固，云计算隐含了一种新的规模化的方法，用于应用程序部署和水平扩展。云计算意味着可以访问大量的资源池，它们被自动调配到适当的机器中以满足工作负载需求。</p><p>云计算带来的直接后果是开发者获得了大量的运算能力，可以用来解决庞大的问题。</p><p>但是云计算的实现并非动动嘴皮子就可以完成的，需要在机器实例之间通信，聚合和存储结果等等，但是最最最困难的莫过于<strong>如何设计并行计算的模型</strong></p><p>接下来将从设计并行计算模型的角度来分析为什么并发很难。</p><hr><h3 id="2-为什么并发很难？"><a href="#2-为什么并发很难？" class="headerlink" title="2 为什么并发很难？"></a>2 为什么并发很难？</h3><h3 id="2-1-Race-Conditions-竞争条件"><a href="#2-1-Race-Conditions-竞争条件" class="headerlink" title="2.1 Race Conditions 竞争条件"></a>2.1 Race Conditions 竞争条件</h3><blockquote><p>当两个或者多个操作必须按正确的顺序执行，而程序并未保证这个顺序，就会发生竞争条件。</p></blockquote><p>也就是说，如果你希望程序的执行顺序为Ａ，但是不恰当的引入并发会导致执行顺序的改变，从而影响程序的准确性。</p><p>同时不正确的导入并发会给程序带来巨大的不稳定性。</p><p>很多程序员解决不确定性的方式是加入耗时操作：比如休眠（time.Sleep()）。但是事实上，错误的代码和错误的逻辑势必会导致错误的结果，加入休眠仅仅使得到的结果在概率上更加接近逻辑的准确性，但是永远不会变成真正的逻辑正确。</p><p>竞争条件可能存在在一段被认为是正确的代码中而不被发现，这种代码只是看上去在用正确的方式来执行，但是事实上只是执行的顺序是正确的这件事情本身的概率比较大而已，最终早晚有可能会出现一些意料之外的结果。</p><h3 id="2-2-Atomicity-原子性"><a href="#2-2-Atomicity-原子性" class="headerlink" title="2.2 Atomicity 原子性"></a>2.2 Atomicity 原子性</h3><blockquote><p>原子性是指：当某些东西被认为是原子时，或者具有原子性的时候。这意味着它在运行的环境中，它是不可分割或者不可中断的。</p></blockquote><p>原子性的判定的一个很重要的条件就是程序的上下文。在一个上下文中可能是原子，在另一个程序中可能就不是一个原子。</p><p>代码的原子性具有一些性质：原子操作的结合并不会产生更大的原子操作。使一个操作成为原子操作应当取决于它的上下文。</p><p>如果某个东西是具有原子性的，则它在并发环境中是安全的。</p><p>因此在并发中，确认代码的哪些部分需要原子化，以及在什么程度和级别上原子化。</p><hr><h3 id="2-3-Memory-Access-Synchronization-内存访问同步"><a href="#2-3-Memory-Access-Synchronization-内存访问同步" class="headerlink" title="2.3 Memory Access Synchronization 内存访问同步"></a>2.3 Memory Access Synchronization 内存访问同步</h3><blockquote><p>在程序中需要独占访问共享资源的部分中，对其对于内存的访问做同步控制。</p></blockquote><p>在接下来的讨论之前，先提及一个概念：<strong>临界区（ Critical Section）</strong>。</p><blockquote><p>程序中需要独占访问共享资源的部分，称为临界区。</p></blockquote><p>临界区是一个代码片段，这个代码片段的特点是<strong>独占了对于共享资源的访问</strong>。</p><p>现在假设两个并发进程试图访问相同的内存区域，它们访问内存的方式不是原子的（即可以被中断的）。<br>那么为了保证一个临界区内的代码能够按照预期的来执行，也就是访问内存的过程不被中断（因为这会给程序带来更大的不稳定性），我们就必须保证一个临界区内对于内存的访问的稳定性。</p><p>既然无法改变读写内存的原子性，我们就使用锁（Lock）来解决内存访问同步的问题（这实际上很常见，从数据库原理中我们也经常见到，锁在计算机系统和网络资源的访问控制上也很常见）。</p><p><strong>给每个临界区加锁，这就可以了吗？</strong></p><p>频繁的加锁是程序运行的效率变低了，但是在我们的眼中这显然要比程序的逻辑是错误的要好的多。</p><p>在考虑临界区的对于内存访问的控制的问题的时候我们需要考虑两个问题：</p><ul><li>我的临界区是否应该频繁进入和退出？</li><li>我的临界区应该有多大？</li></ul><blockquote><p>在程序的上下文中解决这两个问题是一种艺术，并且增加了内存访问同步的难度。</p></blockquote><hr><h3 id="2-4-Deadlocks-Livelocks-and-Starvation-死锁、活锁和饥饿"><a href="#2-4-Deadlocks-Livelocks-and-Starvation-死锁、活锁和饥饿" class="headerlink" title="2.4 Deadlocks, Livelocks, and Starvation 死锁、活锁和饥饿"></a>2.4 Deadlocks, Livelocks, and Starvation 死锁、活锁和饥饿</h3><p><strong>竞争条件，原子性和内存访问同步</strong>的讨论主要的意义在于维持你程序的<strong>正确性</strong>：并非只是在当前的测试和运行中能够拿到正确的结果，而是代码在<strong>逻辑上</strong>就是正确的。这样就可以保证程序的输出永远是正确的。这非常的重要。</p><p>但是在之前的讨论中留下了一些问题： 我们虽然使用了锁来保证了内存访问的同步，但是锁的引入也造成了效率的下降，以致于我们不得不去思考我们的临界区应该如何分布和控制。</p><p><strong>不正当的使用锁会导致你的程序完全停止运行！</strong></p><p>这一类问题就是：死锁、活锁和饥饿</p><h4 id="2-4-1-Deadlocks-死锁"><a href="#2-4-1-Deadlocks-死锁" class="headerlink" title="2.4.1 Deadlocks 死锁"></a>2.4.1 Deadlocks 死锁</h4><p>死锁在gopher的世界中永远是常见的，从字面意思来看也十分的清晰：锁死掉了，也就是永远都不会打开了。</p><blockquote><p>死锁程序是所有并发进程彼此等待的程序，在这种情况下，如果没有外界的干预，这个程序将永远无法回复。</p></blockquote><p>如何构成一个死锁呢？其实非常的简单。这本书提供了一个最简单的例子：有两个goroutine对两个资源AB先后进行访问，但是goroutineA先访问A后访问B，goroutineB先访问B后访问A。而在两次访问之间有耗时操作。</p><p>究竟会导致什么后果呢？</p><p> <img src="https://img-blog.csdnimg.cn/20190513162509405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br> 上图很形象的描述了会发生的情况：</p><ul><li>内存资源A锁了</li><li>内存资源B锁了</li><li>对方都互相等着对面释放锁，于是等啊等啊等啊～</li></ul><p><strong>Deadlocks这次让我们的程序直接宕掉了。</strong></p><p>死锁真的不好啊，虽然golang会自动帮我们检测死锁的发生，但是这毕竟是不够的。我们需要自己去检测程序中发生死锁的可能性。万幸的是，早在1971年一位名叫Edgar Coffman的人就在论文中列举了产生死锁的条件：现在被成为Coffman条件。</p><blockquote><ul><li>相互排斥<ul><li>并发进程同时拥有对于资源的独占权</li></ul></li><li>等待条件<ul><li>并发进程必须同时拥有一个资源，并且等待额外的资源</li></ul></li><li>没有抢占<ul><li>并发进程拥有的资源只能被该进程释放，即可满足这个条件</li></ul></li><li>循环等待<ul><li>一个并发进程必须等待一系列其他并发进程，这些并发进程同时也在等待该进程，这样就满足了最终的条件</li></ul></li></ul></blockquote><h4 id="2-4-2-Livelocks-活锁"><a href="#2-4-2-Livelocks-活锁" class="headerlink" title="2.4.2 Livelocks 活锁"></a>2.4.2 Livelocks 活锁</h4><p>谦让是中国人自古以来的优良传统。</p><p>先讲一个故事：</p><blockquote><p>你在马路上骑车，然后对面也有人骑车过来，你们刚好正对。于是你们双方以同样的反应速度发挥中国人的优良传统：谦让。然后你们同时左拐右拐….终于你们撞上了….</p></blockquote><p>这就是活锁。</p><blockquote><p>活锁是正在主动执行并发操作的程序，但是这些操作无法向前推进程序的状态。</p></blockquote><p>产生活锁的常见的原因便是：两个或者两个以上的并发进程试图在没有协调的情况下防止死锁。</p><h4 id="2-4-3-Starvation-饥饿"><a href="#2-4-3-Starvation-饥饿" class="headerlink" title="2.4.3 Starvation 饥饿"></a>2.4.3 Starvation 饥饿</h4><p>这里的饥饿是指并发进程对于内存的访问控制权的饥饿，也就是一些并发进程会比另外一些进程更加的横行霸道。</p><blockquote><p>饥饿是在任何情况下，并发进程都无法获得执行工作所需的所有资源。</p></blockquote><p>这个贪婪的，横行霸道的并发进程不公平的组织一个或者多个并发进程，导致自己的工作效率高但是其他并发进程的工作效率被排挤。</p><p>一个稍微有一点良心的并发进程，在结束对于一个资源的原子性的操作后，会选择释放锁。<br>但是一个没有良心的并发进程，它会自始至终以尽可能长的时间来霸占锁。</p><p>这是多么的多么的…emmm霸道啊？</p><hr><h3 id="2-5-Determining-Concurrency-Safety-确定并发安全"><a href="#2-5-Determining-Concurrency-Safety-确定并发安全" class="headerlink" title="2.5 Determining Concurrency Safety 确定并发安全"></a>2.5 Determining Concurrency Safety 确定并发安全</h3><p>如何确定并发的安全呢？</p><p>在协同工作的时代，大家使用的代码很可能不出自自己的手，这意味着为了确定并发安全，代码的开发者需要加上注释！</p><p>不然的话，一个新手面对一段代码：</p><ul><li>如何使用这个函数？</li><li>为了并发的调用，我是否需要多次实例化这个函数啊？</li><li>我要不要内存访问同步啊？？？</li></ul><p>一旦这些问题没有一个确定的答案，很显然有可能出现一些奇奇怪怪的后果。没有人希望这样。</p><p>所以：<strong>写注释</strong>！</p><hr><h3 id="3-面对复杂性的简单性"><a href="#3-面对复杂性的简单性" class="headerlink" title="3 面对复杂性的简单性"></a>3 面对复杂性的简单性</h3><p>这一节大概就是狠狠地吹了一顿golang。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《Concurrency-in-Go》&quot;&gt;&lt;a href=&quot;#《Concurrency-in-Go》&quot; class=&quot;headerlink&quot; title=&quot;《Concurrency in Go》&quot;&gt;&lt;/a&gt;《Concurrency in Go》&lt;/h1&gt;&lt;hr&gt;

      
    
    </summary>
    
    
    
      <category term="Concurrency in Go" scheme="http://shiinaorez.github.com/tags/Concurrency-in-Go/"/>
    
  </entry>
  
  <entry>
    <title>自平衡二叉查找树 -- AVL树 Adelson-Velsky-Landis Tree</title>
    <link href="http://shiinaorez.github.com/2019/05/08/AVLTree/"/>
    <id>http://shiinaorez.github.com/2019/05/08/AVLTree/</id>
    <published>2019-05-08T10:24:59.000Z</published>
    <updated>2019-05-08T10:25:58.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="平衡还是不平衡，这是一个问题"><a href="#平衡还是不平衡，这是一个问题" class="headerlink" title="平衡还是不平衡，这是一个问题"></a>平衡还是不平衡，这是一个问题</h2><p>😳：平衡好不好呢？<br>🤣：我说它好。<br>😳：好在哪里呢？<br>🤣：我只能告诉你无可奉告。</p><p>以上的对话是大多数人的反应，对于数据结构中的树形结构为什么平衡会比较好不求甚解。只是大概会比不平衡好吧，毕竟万物都是追求和谐的。</p><p>树形结构的平衡好不好？当然好了，这就是产生树的基本思想啊，因为极端的不平衡就是线性表啊。</p><p>所谓树形结构的平衡性，就是指尽量使树中的节点的子树的深度都大致相同，最理想的情况就是类似于完全二叉树那样的形状。<br><img src="https://img-blog.csdnimg.cn/20190508150412872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>平衡带来的好处有什么呢？<br>🤣操作时间复杂度低，诸如查询，插入，删除等等curd<br>🤣好像没了，但是数据结构不就是最在意这个吗</p><hr><h2 id="什么是二叉查找树？"><a href="#什么是二叉查找树？" class="headerlink" title="什么是二叉查找树？"></a>什么是二叉查找树？</h2><p>这一节大概讲的都是废话。。一般来看这个文章的应该都知道二叉查找树是什么吧。。</p><p>Binary Search Tree，BST就是二叉查找树，遵循最基本的“查找树”的性质：</p><ul><li>对于树中的任意一个节点：<ul><li>如果这个节点的左子树不为空，则左子树上的所有节点都小于该节点的值</li><li>如果这个节点的右子树不为空，则右子树上的所有节点都小于该节点的值</li></ul></li></ul><p>也就是：[左子树的所有的节点] 该节点 [右子树的所有的节点]<br>是不是长的和<strong>快速排序</strong>有点像？</p><p>就是因为维持了这样的性质，达到了很好的效果：</p><ul><li>所有的数据是有序的</li><li>查找数据的时间和二分查找几乎等同（平衡时相等）</li></ul><h3 id="为什么说平衡时相等？"><a href="#为什么说平衡时相等？" class="headerlink" title="为什么说平衡时相等？"></a>为什么说平衡时相等？</h3><p>考虑最极端的情况嘛。。就是一个链条，这样的时间复杂度就是O(N)了</p><hr><h2 id="如何达到自平衡的效果？"><a href="#如何达到自平衡的效果？" class="headerlink" title="如何达到自平衡的效果？"></a>如何达到自平衡的效果？</h2><p>AVL树中引入了平衡因子的概念：</p><pre><code>平衡因子：某个结点的左子树的高度减去右子树的高度得到的差值。</code></pre><p>也就是说，一个平衡的树就是所有的节点的平衡因子的绝对值都是小于等于1的。</p><p>🌛 🌜：爱的魔力转圈圈～</p><p><strong>旋转</strong>，通过旋转来达到自平衡。</p><p>问题来了，现在相信大家对于旋转是个什么鬼东西很疑惑</p><h3 id="什么是旋转？"><a href="#什么是旋转？" class="headerlink" title="什么是旋转？"></a>什么是旋转？</h3><p>我们假设我们有一棵平衡的树，然后我们按照二叉搜索树的原则进行插入：我们大概率会破坏这棵树的平衡性。<br>最常见的一种情况便是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   🤣                                    🤣</span><br><span class="line">  /                ---- &gt;               /  </span><br><span class="line">😜                                    😜</span><br><span class="line">                                     /</span><br><span class="line">                                   🙄</span><br></pre></td></tr></table></figure><p>这简直太糟糕了，这样下去我们的可爱的BST就要变成链表了！<br>我们不能放纵我们的可爱的BST，不能让它随意生长，因此我们要：旋转。</p><p>在这里我们可以看出 🤣 &gt; 😜 &gt; 🙄，而这种情况下😜作为根节点（父节点）才是最优的选择。<br>因此我们就旋转一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      🤣                                    😜</span><br><span class="line">     /                ---- &gt;               /  \</span><br><span class="line">   😜                                    🙄    🤣</span><br><span class="line">  /</span><br><span class="line">🙄</span><br></pre></td></tr></table></figure></p><p>这种情况称之为左左情况：在本来树向左倾斜的情况下又在左子树增加元素。进行右旋。<br>相同的：右右情况进行左旋。<br>左右情况：先左旋后右旋。<br>右左情况：先右旋后左旋。</p><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><h3 id="节点-Node"><a href="#节点-Node" class="headerlink" title="节点 - Node"></a>节点 - Node</h3><p>一个节点应该拥有哪些属性呢？</p><p>🤷‍♂️肯定要有左右子节点的指针吧！<br>🤷‍♂️要有平衡因子，嗯，这样才知道什么时候应该旋转。<br>🤷‍♂️为了方便计算平衡因子，应该缓存一下高度。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data    <span class="keyword">int</span></span><br><span class="line">    Height  <span class="keyword">int</span></span><br><span class="line">    Left    *Node;</span><br><span class="line">    Right   *Node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="递归计算节点的高度"><a href="#递归计算节点的高度" class="headerlink" title="递归计算节点的高度"></a>递归计算节点的高度</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *Node)</span><span class="title">TreeHeight</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(root.Left.TreeHeight(), root.Roght.TreeHeight()) + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算平衡因子"><a href="#计算平衡因子" class="headerlink" title="计算平衡因子"></a>计算平衡因子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *Node)</span><span class="title">TreeGetBalanceFactor</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.Left.Height - root.Right.Height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *Node)</span><span class="title">TreeRotateRight</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    left := root.Left</span><br><span class="line">    </span><br><span class="line">    root.Left = Left.Right <span class="comment">// 将将要被抛弃的节点连接为旋转后的 root 的左孩子</span></span><br><span class="line">    left.Right = root      <span class="comment">// 调换父子关系</span></span><br><span class="line"></span><br><span class="line">    left.Height = max(left.Left.TreeHeight(), left.Right.TreeHeight())+<span class="number">1</span></span><br><span class="line">    root.Right.Height = max(root.Right.Left.TreeHeight(), root.Right.Right.TreeHeight())+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(root *Node)</span><span class="title">TreeRotateLeft</span><span class="params">()</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">    right := root.Right</span><br><span class="line"></span><br><span class="line">    root.Right = right.Left</span><br><span class="line">    right.Left = root</span><br><span class="line"></span><br><span class="line">    root.Left.Height = max(root.Left.Left.TreeHeight(), root.Left.Right.TreeHeight())+<span class="number">1</span></span><br><span class="line">    right.Height = max(right.Left.TreeHeight(), right.Left.TreeHeight())+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搞懂了吗？-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️"><a href="#搞懂了吗？-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️🤷🏻‍♀️-🤷🏻‍♂️" class="headerlink" title="搞懂了吗？ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️"></a>搞懂了吗？ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️🤷🏻‍♀️ 🤷🏻‍♂️</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;平衡还是不平衡，这是一个问题&quot;&gt;&lt;a href=&quot;#平衡还是不平衡，这是一个问题&quot; class=&quot;headerlink&quot; title=&quot;平衡还是不平衡，这是一个问题&quot;&gt;&lt;/a&gt;平衡还是不平衡，这是一个问题&lt;/h2&gt;&lt;p&gt;😳：平衡好不好呢？&lt;br&gt;🤣：我说它好。
      
    
    </summary>
    
    
    
      <category term="Algorithm DataStructure" scheme="http://shiinaorez.github.com/tags/Algorithm-DataStructure/"/>
    
  </entry>
  
  <entry>
    <title>康托展开 Cantor Expansion</title>
    <link href="http://shiinaorez.github.com/2019/05/06/cantor/"/>
    <id>http://shiinaorez.github.com/2019/05/06/cantor/</id>
    <published>2019-05-06T11:52:43.000Z</published>
    <updated>2019-05-06T11:54:20.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全排列一直是一个让人联想到爆炸复杂度的东西"><a href="#全排列一直是一个让人联想到爆炸复杂度的东西" class="headerlink" title="全排列一直是一个让人联想到爆炸复杂度的东西"></a>全排列一直是一个让人联想到爆炸复杂度的东西</h2><p>如果一件事情牵扯到了全排列，大多数人脑中一定都是这样子的：高中学习的排列组合、排列数、组合数、数不清的阶乘、大学的组合数学等等一系列让人头疼的东西。</p><p>如果你写过一点点OI相关的题目，或者在Leetcode等网站上刷过题，那么你一定使用过各种语言写过这样的题目：生成全排列。考点大概就是回溯。</p><p>n的数有n！个全排列，生成的算法也有很多种：字典序法，插入法，邻为对换法，递增进位制法等等。不论你们去简化过程，每个全排列总还是要遍历到的。</p><p>不过既然全排列一定是有序的，我们一定可以通过某一个数来确定一个唯一的全排列吧！</p><p>是的，这个想法是对的，这就是康托展开（Cantor expansion）。</p><h2 id="康托展开的基本思想"><a href="#康托展开的基本思想" class="headerlink" title="康托展开的基本思想"></a>康托展开的基本思想</h2><p>一个全排列一定是由1～n的不重复的数字组成的。而生成的全排列一定是有序的：我们假设就是字典序吧。那么每一位其实就可以确定在这之前有多少全排列。</p><p>以 3 5 7 4 1 2 9 6 8 为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 5 7 4 1 2 9 6 8</span><br><span class="line">↑</span><br><span class="line">3之前有 3-1=2 个以1或者2开头的全排列，共有(9-1)! * (3-1) 个</span><br><span class="line">3 5 7 4 1 2 9 6 8</span><br><span class="line">  ↑</span><br><span class="line">5之前除去3有5-1-1=3 个以1或2或4开头的长度为7的全排列，共有(9-2)! * (5-2)个</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>按照这样的情况我们就可以使用一个式子来表示3 5 7 4 1 2 9 6 8之前有多少个全排列了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 * 8! + 3 * 7! + 4 * 6! + 2 * 5! + 0 * 4! + 0 * 3! + 2 * 2! + 0 * 1! + 0 * 0!</span><br></pre></td></tr></table></figure><h2 id="代码实现？"><a href="#代码实现？" class="headerlink" title="代码实现？"></a>代码实现？</h2><p>最近在写Go嘛，所以就…<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseCantor</span><span class="params">(n <span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 逆康托展开，接收一个数字返回相应的全排列</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//存放阶乘</span></span><br><span class="line">facs := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>&#125;</span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=n; i++ &#123;</span><br><span class="line">        nums = <span class="built_in">append</span>(nums, i)</span><br><span class="line">    &#125;</span><br><span class="line">    res := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">    k -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j:=n; j&gt;=<span class="number">1</span>; j-- &#123;</span><br><span class="line">        r := k % facs[j<span class="number">-1</span>];</span><br><span class="line">        t := k / facs[j<span class="number">-1</span>];</span><br><span class="line">        k = r;</span><br><span class="line">        res = <span class="built_in">append</span>(res, nums[t])</span><br><span class="line">        nums = <span class="built_in">append</span>(nums[:t], nums[t+<span class="number">1</span>:]...)</span><br><span class="line">    &#125;</span><br><span class="line">    bytes := []<span class="keyword">byte</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> res &#123;</span><br><span class="line">        bytes = <span class="built_in">append</span>(bytes, <span class="keyword">byte</span>(<span class="number">48</span> + v))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(bytes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://img-blog.csdnimg.cn/20190506183209389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全排列一直是一个让人联想到爆炸复杂度的东西&quot;&gt;&lt;a href=&quot;#全排列一直是一个让人联想到爆炸复杂度的东西&quot; class=&quot;headerlink&quot; title=&quot;全排列一直是一个让人联想到爆炸复杂度的东西&quot;&gt;&lt;/a&gt;全排列一直是一个让人联想到爆炸复杂度的东西&lt;/
      
    
    </summary>
    
    
    
      <category term="Algorithm" scheme="http://shiinaorez.github.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>《Call Werkzeug系列之：预备知识-Cookie》</title>
    <link href="http://shiinaorez.github.com/2019/04/23/CallWerkzeug_cookie/"/>
    <id>http://shiinaorez.github.com/2019/04/23/CallWerkzeug_cookie/</id>
    <published>2019-04-23T03:05:30.000Z</published>
    <updated>2019-04-23T03:12:20.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码中对应的场景："><a href="#源码中对应的场景：" class="headerlink" title="源码中对应的场景："></a>源码中对应的场景：</h2><p>在 <strong>werkzeug.wrappers.BaseRequest.delete_cookie()</strong>和<strong>werkzeug.wrappers.BaseRequest.set_cookie()</strong></p><p>方法的参数中出现了path和domain。<br>在看到的时候不是很理解，只是大概知道是中文路径和域的意思，在查阅了相关资料之后做一个总结。</p><hr><h2 id="path："><a href="#path：" class="headerlink" title="path："></a>path：</h2><pre><code>path代表cookie所在的目录，默认为&apos;/&apos;，也就是根目录。</code></pre><h3 id="访问限制："><a href="#访问限制：" class="headerlink" title="访问限制："></a>访问限制：</h3><p>在同一个服务器上有目录如下：<br><strong>/test/</strong>、<strong>/test/cd/</strong>、<strong>/test/dd/</strong><br>则<strong>path = /test/</strong>的cookie对于全部目录下都可以访问。<br>　<strong>path = /test/cd/</strong>的cookie不能被<strong>/test/dd/</strong>下所访问。</p><hr><h2 id="domain："><a href="#domain：" class="headerlink" title="domain："></a>domain：</h2><pre><code>domain为cookie所在的域，默认为请求的地址。</code></pre><p>若访问<strong><a href="http://www.test.com/test/test.jpg" target="_blank" rel="noopener">www.test.com/test/test.jpg</a></strong>，则domain默认为<strong><a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></strong></p><h3 id="跨域访问："><a href="#跨域访问：" class="headerlink" title="跨域访问："></a>跨域访问：</h3><p>设域A：<strong>t1.test.com</strong><br>   域B：<strong>t2.test.com</strong><br>则域A域B都能访问的cookie域应该设为<strong>.test.com</strong><br>域A不能访问，域B能访问：设为<strong>t2.test.com</strong></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码中对应的场景：&quot;&gt;&lt;a href=&quot;#源码中对应的场景：&quot; class=&quot;headerlink&quot; title=&quot;源码中对应的场景：&quot;&gt;&lt;/a&gt;源码中对应的场景：&lt;/h2&gt;&lt;p&gt;在 &lt;strong&gt;werkzeug.wrappers.BaseRequest.de
      
    
    </summary>
    
    
    
      <category term="Werkzeug" scheme="http://shiinaorez.github.com/tags/Werkzeug/"/>
    
  </entry>
  
  <entry>
    <title>《Call Werkzeug系列之：导读-Wrappers》</title>
    <link href="http://shiinaorez.github.com/2019/04/23/CallWerkzeug_wrappers/"/>
    <id>http://shiinaorez.github.com/2019/04/23/CallWerkzeug_wrappers/</id>
    <published>2019-04-23T03:04:30.000Z</published>
    <updated>2019-04-23T03:09:54.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>WRAPPERS，即<strong>wrappers.py</strong>。包含了请求基类（BaseRequest）、响应基类（BaseResponse）和诸多的混入类（Mixin Classes）。<br><strong>wrappers.py</strong>是我选择进行源码解读的第一个入口，因为在写Web应用的过程中永远是离不开<strong>请求</strong>和<strong>响应</strong>的，那么首当其冲的就是要理解这两个至关重要又联系紧密的类了。</p><p>在<strong>wrappers.py</strong>中，首先映入眼帘的是开发者们留下的一段话：</p><p><strong>The request and response objects wrap the WSGI environment or the return value from a WSGI application so that is another WSGI application (wraps a while application).<br>请求和响应对象分别封装了WSGI环境变量和由一个符合WSGI标准的应用返回的数据，所以其实这是另一种形式的WSGI应用。</strong></p><p>分开详细的讨论一下：</p><ul><li>Request Object：<ul><li>接受WSGI-Environment为参数进行初始化，并且提供了<strong>一系列的方法</strong>用来解析和利用<strong>environ</strong>中的信息，方便客户代码更友好的利用这些来自底层的数据。</li></ul></li><li>Response Object：<ul><li>接受数据和一个<strong>mimetype</strong>作为参数进行初始化，并且实例是一个<strong>可调用对象</strong>（Callable），类似的，和WSGI-Application一样，接受两个参数：<strong>environ</strong>和<strong>start_response</strong>。接下来便来看一下是如何调用的。</li></ul></li></ul><hr><h2 id="werkzeug-wrappers-BaseResponse-call"><a href="#werkzeug-wrappers-BaseResponse-call" class="headerlink" title="werkzeug.wrappers.BaseResponse.call()"></a><strong>werkzeug.wrappers.BaseResponse.<strong>call</strong>()</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">    app_iter, status, headers = self.get_wsgi_response(environ)</span><br><span class="line">    start_response(status, headers)</span><br><span class="line">    <span class="keyword">return</span> app_iter</span><br></pre></td></tr></table></figure><hr><h2 id="Request和Response的应用场景："><a href="#Request和Response的应用场景：" class="headerlink" title="Request和Response的应用场景："></a>Request和Response的应用场景：</h2><p>接下来将通过<strong>Request</strong>和<strong>Response</strong>来写一个符合WSGI规范的小小应用，来帮助理解他们的应用场景;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> werkzeug.wrappers <span class="keyword">import</span> Request, Response</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    request = Request(environ)</span><br><span class="line">    response = Response(<span class="string">"Hello, %s!"</span> % request.args.get(<span class="string">'name'</span>))</span><br><span class="line">    <span class="keyword">return</span> response(environ, start_response)</span><br></pre></td></tr></table></figure><p>以上代码展示了很基础的，微小的应用，它的逻辑是非常清晰的：</p><ul><li>组织请求</li><li>由请求构建响应</li><li>返回数据</li></ul><p>在现如今的应用中，基本都符合这种“请求-响应”模式。<strong>在该模式中，构建请求的相似度极高，而对请求的处理逻辑是每个应用的特点和灵魂。</strong>因此werkzeug使用了装饰器句法，讲处理<strong>environ</strong>为请求的部分抽离了出来。<br>[我觉得可能这是开创了使用装饰器句法装饰view_function的先河]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Request.application</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(request)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>现在我们就要正式的开始我们的“第一个”解析源码的过程了：</p><hr><h2 id="werkzeug-wrappers-BaseRequest-application"><a href="#werkzeug-wrappers-BaseRequest-application" class="headerlink" title="werkzeug.wrappers.BaseRequest.application()"></a><strong>werkzeug.wrappers.BaseRequest.application()</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(cls, f)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> werkzeug.exceptions <span class="keyword">import</span> HTTPException</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">application</span><span class="params">(*args)</span>:</span></span><br><span class="line">        request = cls(args[<span class="number">-2</span>])</span><br><span class="line">        <span class="keyword">with</span> request:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                resp = f(*args[:<span class="number">-2</span>]+(request,))</span><br><span class="line">            <span class="keyword">except</span> HTTPException <span class="keyword">as</span> e:</span><br><span class="line">                resp = e.get_response(args[<span class="number">-2</span>])</span><br><span class="line">            <span class="keyword">return</span> resp(*args[<span class="number">-2</span>:])</span><br><span class="line">    <span class="keyword">return</span> update_wrapper(application, f)</span><br></pre></td></tr></table></figure><p>第一眼看到这个东西我是真的不想读，真的真的不想读。</p><p>首先要解决看不懂的方法：<strong>get_response()</strong>、<strong>update_wrapper()</strong></p><h3 id="werkzeug-exceptions-HTTPException-get-response"><a href="#werkzeug-exceptions-HTTPException-get-response" class="headerlink" title="werkzeug.exceptions.HTTPException.get_response()"></a><strong>werkzeug.exceptions.HTTPException.get_response()</strong></h3><p>该方法的注释是这么写的：</p><p>Get a response object. If one was passed to the exception it’s returned directly.<br>那么这个方法的目的就相当明显，就是<strong>从错误类中获取响应对象</strong>。</p><h3 id="functools-update-wrapper"><a href="#functools-update-wrapper" class="headerlink" title="functools.update_wrapper()"></a><strong>functools.update_wrapper()</strong></h3><p>该方法用于保持函数签名。著名的<strong>functools.wraps</strong>装饰器就是由这个方法实现的。</p><p>在解决了这两个看上去陌生的方法之后，我们继续分析application：</p><ul><li>导入了werkzeug中所有错误类的基类：<strong>HTTPException</strong></li><li>在内部定义的<strong>application()</strong>中，使用<strong>args[-2]</strong>来获取<strong>environ</strong>用于初始化<strong>BaseRequest</strong></li><li>以生成的request实例为上下文管理器：<ul><li>获取一个响应对象并返回，即实现原本被装饰函数的功能</li><li>尝试将原参数元组最后的两个参数替换为request对象</li><li>否则，则从错误类获取响应</li></ul></li></ul><p>有趣之处在于使用的<strong>with</strong>句法：显然就需要去看一下<strong><strong>enter</strong>()</strong>和<strong><strong>exit</strong>()</strong>这两个魔法方法（Magic Method）<br>但是我们找了以下注释：</p><p>Closes associated resources of this request object.  This closes <strong>all file handles</strong> explicitly. <strong>You can also use request object in a with statement which will automatically close it.</strong></p><p>由此我们可以得知，请求时不只是有单纯的数据流动，也有可能涉及到文件的打开什么的。这个时候使用<strong>with</strong>，最后在<strong><strong>exit</strong>()</strong>中同意关闭文件是最理想的选择。</p><hr><p>接下来就是要正式接触对于源码的解析了w<br>真的好让人<strong>兴♂奋</strong>啊~！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;WRAPPERS，即&lt;strong&gt;wrappers.py&lt;/strong&gt;。包含了请求基类（BaseRequest）、响应基类（B
      
    
    </summary>
    
    
    
      <category term="Werkzeug" scheme="http://shiinaorez.github.com/tags/Werkzeug/"/>
    
  </entry>
  
  <entry>
    <title>《Call Werkzeug系列之：开始》</title>
    <link href="http://shiinaorez.github.com/2019/04/10/CallWerkzeug_start/"/>
    <id>http://shiinaorez.github.com/2019/04/10/CallWerkzeug_start/</id>
    <published>2019-04-10T13:36:30.000Z</published>
    <updated>2019-04-10T13:37:05.868Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="前言：Werkzeug"><a href="#前言：Werkzeug" class="headerlink" title="前言：Werkzeug"></a>前言：Werkzeug</h2><p><a href="https://github.com/pallets/werkzeug" target="_blank" rel="noopener">werkzeug</a>是使用Python语言编写的一个web后端工具包，提供了相当多的功能，并且是基于<a href="https://www.python.org/dev/peps/pep-0333/" target="_blank" rel="noopener">PEP 333:WSGI</a>标准的，因此易于扩展。现如今许多的服务器端框架都是使用werkzeug的，比如<a href="https://github.com/pallets/flask" target="_blank" rel="noopener">flask</a>。</p><hr><h2 id="标准：WSGI"><a href="#标准：WSGI" class="headerlink" title="标准：WSGI"></a>标准：WSGI</h2><p>WSGI是<strong>web server gateway interface</strong>的意思，即web服务器网关接口。是在PEP 333中提出用于规范服务端接口协议的。</p><pre><code>PEP（Python增强建议书）： 是Python Enhancement Proposals的缩写。一个PEP是一份为Python社区提供各种增强功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。</code></pre><p><strong>WSGI指出以下几点：</strong></p><ul><li>WSGI接口分为两端：<ul><li>服务器/网关端</li><li>应用程序/Web框架端</li></ul></li><li>应用程序端给服务器端提供一个可调用者（<strong>Callable</strong>），而服务器端如何使用它则取决于其本身。</li><li><p>应用程序/Web框架端：</p><ul><li>应用程序对象：一个接受两个参数的<strong>Callable Object</strong><ul><li>参数（environ，start_response）：<ul><li>environ：字典对象。字面意思是请求环境的意思，包含了一个请求应该包含的所有信息，被封装为符合标准的WSGI Environment对象。</li><li>start_response：一个<strong>Callable</strong>，返回值是一个<strong>Callable</strong>或者一个能包含零个或多个字符串的可迭代对象（<strong>Iterable</strong>）。<ul><li>参数（status，response_headers，*exc_info）：<ul><li>status：一个由状态码和描述拼接成的字符串。形如：<figure class="highlight plain"><figcaption><span>OK"```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ response_headers：响应头。是一个列表元组。</span><br><span class="line">+ exc_info：可选参数，用于描述错误信息。</span><br><span class="line">+ 服务器/网关端：每当HTTP客户端向应用程序发来一个请求，都会调用应用程序返回的**Callable**。</span><br><span class="line"></span><br><span class="line">经过以上的描述，相信能对WSGI有一个基本的认识了，其实WSGI只是一套规范而已。但是这个规范其实远远不止这些，包括environ在内的几乎所有内容都有严格的定义。因此在后面的解释中**经常以WSGI为前缀来表示“符合WSGI标准的”**的意思。</span><br><span class="line"></span><br><span class="line">在PEP 333中详尽地描述了WSGI，有兴趣可以阅读@miaomiaomiao翻译后的PEP 333文档。</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line">## 源码：文件结构</span><br><span class="line"></span><br><span class="line">作为一个工具包，werkzeug有着很严谨的文件结构。</span><br><span class="line"></span><br><span class="line">+ ```__init__.py</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li></ul></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ ```_internal.py```：**提供了werkzeug中使用的一些常量和基类。**</span><br><span class="line">+ ```_reload.py```：重新加载模块</span><br><span class="line">+ ```datastructures.py```：**数据结构模块，用来存放整合数据的类。**</span><br><span class="line">+ ```exceptions.py```：**错误处理模块。用来存放各种错误类。**</span><br><span class="line">+ ```filesystem.py```：文件系统模块。</span><br><span class="line">+ ```formparser.py```：**表单解析模块。提供用于解析表单数据的工具函数。**</span><br><span class="line">+ ```http.py```：**用于处理HTTP中的数据的工具们。在wrapper.py中使用的比较多，但是这些工具函数往往单独使用作用更加显著，尤其是在没有请求和响应对象的前提下。**</span><br><span class="line">+ ```local.py```：本地上下文对象。</span><br><span class="line">+ ```posixemulation.py```：为应用程序提供可移植作业系统接口（Portable Operating System Interface，POSIX）。</span><br><span class="line">+ ```routing.py```：**路由匹配处理模块。**</span><br><span class="line">+ ```security.py```：安全模块。</span><br><span class="line">+ ```serving.py```：服务运行模块。</span><br><span class="line">+ ```test.py&amp;testapp.py</span><br></pre></td></tr></table></figure></li><li><p><code>url.py</code>：<strong>处理解析URL的工具们。</strong></p></li><li><code>useragents.py</code>：用于处理用户代理的工具们。</li><li><code>utils.py</code>：<strong>用于实现封装好的请求类和响应类的模块。对于中间件开发十分重要。</strong></li><li><code>wrappers.py</code>：<strong>封装好的各种类。包括著名的请求基类和响应基类和各种混入类。</strong></li><li><code>wsgi.py</code>：WSGI相关模块。</li></ul><p>加粗的是我认为比较重要且核心的模块。会在以后依次深入解读。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h2 id=&quot;前言：Werkzeug&quot;&gt;&lt;a href=&quot;#前言：Werkzeug&quot; class=&quot;headerlink&quot; title=&quot;前言：Werkzeug&quot;&gt;&lt;/a&gt;前言：Werkzeug&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/p
      
    
    </summary>
    
    
    
      <category term="Werkzeug" scheme="http://shiinaorez.github.com/tags/Werkzeug/"/>
    
  </entry>
  
  <entry>
    <title>《Call Werkzeug系列之：WSGI Environment》</title>
    <link href="http://shiinaorez.github.com/2019/04/10/CallWerkzeug_wsgi_environment/"/>
    <id>http://shiinaorez.github.com/2019/04/10/CallWerkzeug_wsgi_environment/</id>
    <published>2019-04-10T13:33:30.000Z</published>
    <updated>2019-04-10T13:34:04.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WSGI-Environment是什么："><a href="#WSGI-Environment是什么：" class="headerlink" title="WSGI-Environment是什么："></a>WSGI-Environment是什么：</h2><p>WSGI-Environment，就是在代码中最常见的<strong>environ</strong>。<br>environ<strong>字典</strong>被用来包含<strong>CGI</strong>(Common Gateway Interface，必须的网关接口)环境变量，除非是空字符串，否则所有以下将要介绍的变量都<strong>必须</strong>指定，但是在空字符串的情况下，他们会被忽略。除非特殊说明。<br>简而言之：<strong>environ是一个字典，包含请求中所有的环境变量</strong></p><hr><h2 id="environ经典情况下包含的键值对："><a href="#environ经典情况下包含的键值对：" class="headerlink" title="environ经典情况下包含的键值对："></a>environ经典情况下包含的键值对：</h2><table><thead><tr><th>Key</th><th>Value</th><th>Required</th><th>Meaning</th><th>Example</th></tr></thead><tbody><tr><td>REQUEST_METHOD</td><td>string</td><td>√</td><td>HTTP的请求方式</td><td>“GET”</td></tr><tr><td>SCRIPT_NAME</td><td>string</td><td></td><td>URL请求中path的开始部分，对应了应用程序对象</td><td>“/api/v1”</td></tr><tr><td>PATH_INFO</td><td>string</td><td></td><td>URL请求中path的其余部分，指定应用程序内部的虚拟位置</td><td>“/login”</td></tr><tr><td>QUERY_STRING</td><td>string</td><td></td><td>请求参数</td><td>“id=10086&amp;page=1”</td></tr><tr><td>CONTENT_TYPE</td><td>string</td><td></td><td>HTTP请求中的Content-Type字段</td><td>“application/json”</td></tr><tr><td>CONTENT-LENGTH</td><td>string</td><td></td><td>HTTP请求中的Content-Length字段</td><td>“18868”</td></tr><tr><td>SERVER_NAME</td><td>string</td><td>√</td><td>服务器名</td><td>“119.27.79.87”</td></tr><tr><td>SERVER_PORT</td><td>string</td><td>√</td><td>服务器端口</td><td>“6666”</td></tr><tr><td>SERVER_PROTOCOL</td><td>string</td><td>√</td><td>HTTP协议版本</td><td>“HTTP/1.0”</td></tr><tr><td>HTTP_*</td><td></td><td></td><td>客户端提供的请求报头们，以”HTTP_”开头</td></tr></tbody></table><hr><h2 id="WSGI要求下的变量："><a href="#WSGI要求下的变量：" class="headerlink" title="WSGI要求下的变量："></a>WSGI要求下的变量：</h2><table><thead><tr><th>Name</th><th>Type</th><th>Meaning</th></tr></thead><tbody><tr><td>wsgi.version</td><td>tuple</td><td>一般为(1,0)，代表WSGI版本1.0</td></tr><tr><td>wsgi.url_scheme</td><td>string</td><td>URL的scheme部分，值为”http”或”https”</td></tr><tr><td>wsgi.input</td><td>stream</td><td>一个能被HTTP请求主体读取的输入流</td></tr><tr><td>wgsi.errors</td><td>stream</td><td>用于记录错误信息的输出流，目的是记录程序或者其他标准化及可能的中心化错误。对很对服务器而言，wsgi.errors是服务器的主要错误日志</td></tr><tr><td>wsgi.multithread</td><td>bool</td><td>如果一个应用程序对象同时处于被同一个进程中的不同线程调用，则为True</td></tr><tr><td>wsgi.multiprocess</td><td>bool</td><td>如果相同的应用程序对象同时被其他进程调用，则为True</td></tr><tr><td>wsgi.run_once</td><td>bool</td><td>如果服务器/网关期待（但是不保证）应用程序在它所在的进程生命期间只会被调用一次，则为True</td></tr></tbody></table><hr><h2 id="WSGI-Environment的规范："><a href="#WSGI-Environment的规范：" class="headerlink" title="WSGI-Environment的规范："></a>WSGI-Environment的规范：</h2><ul><li>一个遵循WSGI规范的服务器或网关应该在文档中描述它们自己定义的同时，适当的<strong>说明</strong>一下它们可以提供哪些变量。而应用程序这边则应该对它们要用到的<strong>每一个变量的存在性进行检查</strong>，并且在检测某些变量不存在的时候要有<strong>备用措施</strong>。</li><li>除了<strong>CGI定义的变量</strong>，environ字典也可以包含任何<strong>操作系统相关的环境变量</strong>，并且并且必须包含<strong>第二部分提及的变量</strong>。</li><li>environ字典可能会包含<strong>服务器定义的</strong>变量。这些变量应该用<strong>小写，数字，点号</strong>以及<strong>下划线</strong>来命名，并且必须定义一个该服务器/网关<strong>专有的前缀开头</strong>。</li></ul><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WSGI-Environment是什么：&quot;&gt;&lt;a href=&quot;#WSGI-Environment是什么：&quot; class=&quot;headerlink&quot; title=&quot;WSGI-Environment是什么：&quot;&gt;&lt;/a&gt;WSGI-Environment是什么：&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="Werkzeug" scheme="http://shiinaorez.github.com/tags/Werkzeug/"/>
    
  </entry>
  
  <entry>
    <title>什么是RESTful？</title>
    <link href="http://shiinaorez.github.com/2019/04/10/RESTful/"/>
    <id>http://shiinaorez.github.com/2019/04/10/RESTful/</id>
    <published>2019-04-10T07:18:30.000Z</published>
    <updated>2019-04-10T07:19:17.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h1><h2 id="什么是REST"><a href="#什么是REST" class="headerlink" title="什么是REST"></a>什么是REST</h2><p>RESTful这个词来源于2000年Roy Fielding的<a href="http://ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_blank" rel="noopener">博士论文</a>.<br>(资源)<strong>表现层状态转化</strong>(Representational State Transfer, REST)是REST的真正意思，这里的<strong>资源</strong>并未在这个缩写中体现出来，但是资源却是隐含的最核心的一个概念。</p><ul><li><p>资源</p><ul><li>资源指的是互联网上的一切信息的实体。互联网上的一切信息都可以看作是一个资源。这个资源是一个具体信息，是数据，我们可以用统一资源定位符（URI）来指向我们想要的资源。但是它的表现形式却是不确定的：同样的信息可以有不同的表现形式，这就是一个资源的<strong>表现层</strong>。</li></ul></li><li><p>表现层</p><ul><li>尽管我们可以用URI来描述一个资源，但是同样的资源同样可以有不同的表现形式，URI指定了一个资源的位置，而如何解析表示一个数据的形式其实是多样的。</li></ul></li><li><p>状态转化</p><ul><li>任何时间下，一个资源都有一个<strong>状态</strong>，而客户端对于资源的访问总是会引起状态的变化，否则的话互联网上的资源就是永久不变的了。而这种对于资源状态的转化是基于表面层的。也就是，资源先以一种表现层展示出来，然后才进行状态的转化，也就是表现层状态转化。</li><li>客户端用于操作资源的方式，也就是http协议，拥有许多的请求方式：GET, POST, PUT, DELETE等等，也就是这些操作<strong>真正的实现</strong>了对于资源的表现层状态转化。</li></ul></li></ul><h2 id="资源就是一切-–-RESTful-API"><a href="#资源就是一切-–-RESTful-API" class="headerlink" title="资源就是一切 – RESTful API"></a>资源就是一切 – RESTful API</h2><p>RESTful的精神就是一切都是面向资源的，互联网上的一切操作都是对于资源的CURD，因此首先就是对于资源的描述，也就是URI如何命名：</p><ul><li>一个完整的URI由以下部分组成<ul><li>协议<ul><li>一般是http或https</li></ul></li><li>主域名<ul><li>如api.muxixyz.com</li></ul></li><li>版本<ul><li>/v1.0</li></ul></li><li>路径<ul><li>具体的路径，指向网络上的资源，既可以指向单个的资源，也可以指向资源的集合。指向单个资源时往往加入ID来确定具体的资源。</li><li>路径中对于资源的描述都使用名词，因此不应该出现动词</li><li>表示集合的时候名词应该使用复数</li><li>如/comments, /comments/6</li></ul></li></ul></li></ul><p>描述完资源之后，一个API还应该包括以下信息：</p><ul><li>HTTP动词，也就是请求方式<ul><li>[GET] <a href="https://api.muxixyz.com/users/16/issues" target="_blank" rel="noopener">https://api.muxixyz.com/users/16/issues</a></li><li>[DELETE] <a href="https://api.muxixyz.com/comments/17" target="_blank" rel="noopener">https://api.muxixyz.com/comments/17</a></li></ul></li><li>QueryString – 过滤信息<ul><li>其实大家都知道。。就是query string啦</li><li>比如：/?page=1</li></ul></li><li>HTTP状态码，用于表示操作的结果<ul><li>有一部分的状态码是已经规定好的，也有很多没有规定好的可以方便开发者自己定义</li><li>200 [OK]</li><li>401 [Unauthorized]</li><li>500 [Internal Server Error]</li></ul></li><li>错误处理<ul><li>如果出现了错误应当返回错误信息，服务器也应当有相应的日志记录。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RESTful架构&quot;&gt;&lt;a href=&quot;#RESTful架构&quot; class=&quot;headerlink&quot; title=&quot;RESTful架构&quot;&gt;&lt;/a&gt;RESTful架构&lt;/h1&gt;&lt;h2 id=&quot;什么是REST&quot;&gt;&lt;a href=&quot;#什么是REST&quot; class=&quot;he
      
    
    </summary>
    
    
    
      <category term="软件体系结构" scheme="http://shiinaorez.github.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>设计API时需要注意的点</title>
    <link href="http://shiinaorez.github.com/2019/04/09/API/"/>
    <id>http://shiinaorez.github.com/2019/04/09/API/</id>
    <published>2019-04-09T15:53:30.000Z</published>
    <updated>2019-04-10T07:20:52.149Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计API前读一读"><a href="#设计API前读一读" class="headerlink" title="设计API前读一读"></a>设计API前读一读</h1><h2 id="设计API应该达到的目标："><a href="#设计API应该达到的目标：" class="headerlink" title="设计API应该达到的目标："></a>设计API应该达到的目标：</h2><h3 id="易于学习，易于理解"><a href="#易于学习，易于理解" class="headerlink" title="易于学习，易于理解"></a>易于学习，易于理解</h3><p>应该具有足够的注释和文档进行解释说明，让其他调用者可以很快的上手使用你完成的接口。接口的意义不应该过于复杂，使人便于理解。</p><h3 id="不容易引发歧义"><a href="#不容易引发歧义" class="headerlink" title="不容易引发歧义"></a>不容易引发歧义</h3><p>避免模棱两可，使调用者清楚自己应该使用哪个接口，避免对于接口的错误使用。</p><h3 id="易于扩展"><a href="#易于扩展" class="headerlink" title="易于扩展"></a>易于扩展</h3><p>对于工程的迭代时，应该可以最大限度的复用之前的接口而不破坏整个工程的架构。因此对于接口的设计应该是易于扩展的。</p><h3 id="满足用户需求"><a href="#满足用户需求" class="headerlink" title="满足用户需求"></a>满足用户需求</h3><ul><li>完备性<ul><li>完备性是指接口的设计完全能够完成满足用户需求的目标</li></ul></li><li>正交性<ul><li>数学上的正交大约体现为两个向量的乘积为0，两个向量的乘积被两个向量分别影响，因此乘积为0的情况说明这两个向量无法互相影响。</li><li>API设计中的正交性是在保证完备性的前提下另一个需要注意的点，即尽可能满足所有的API之间是<strong>正交的</strong>，并且使用户需求和具体实现是<strong>正交的</strong>。</li><li>API和API之间是<strong>正交的</strong>可以保证接口之间的<strong>重复功能</strong>最少，这样的接口构成的模块是具有高度稳定性的。</li><li>即用户需求发生变化时，接口的具体实现不需要任何改动，只需要调用者改变调用方式即可满足。即用户需求和具体实现不产生<strong>任何的互相影响</strong>。</li></ul></li></ul><h2 id="如何实现一个好的API设计"><a href="#如何实现一个好的API设计" class="headerlink" title="如何实现一个好的API设计"></a><strong>如何实现一个好的API设计</strong></h2><h3 id="一个API的功能应该是单一的"><a href="#一个API的功能应该是单一的" class="headerlink" title="一个API的功能应该是单一的"></a><strong>一个API的功能应该是单一的</strong></h3><p>所谓单一的功能，是为了一个API可以有<strong>更好的维护</strong>。一个API功能不单一的极端情况就是所谓的<strong>上帝类</strong>，上帝类的意思就是指一个类可以完成一个工程的所有需求，即所有的业务逻辑全部都放在一个类（API）中。</p><p>从现在来看，上帝类其实是一个反人类的存在，这大概很“上帝”了hhh。在软件工程刚刚出现的时候，并没有人考虑到<strong>后期维护</strong>的问题。所以大家的代码全部都写在一起，通过各种goto语句来链接所有的业务逻辑。</p><p><img src="https://i.loli.net/2019/04/07/5ca9ab254defc.png" alt="第一个图"></p><p>但是问题在于这样的实现将产品的具体需求和API的具体实现过于紧密的绑定在了一起：<strong>但凡产品的具体需求发生了改变，体量相当庞大的源代码就需要进行相应的维护和改变。</strong>慢慢的上帝类就变得极其臃肿，难以维护。</p><p>在功能上使每一个API都是一个最小的单元，这样便于在产品的需求发生改变时，能够对最少的源代码进行维护。</p><h3 id="尽量少的外部依赖"><a href="#尽量少的外部依赖" class="headerlink" title="尽量少的外部依赖"></a><strong>尽量少的外部依赖</strong></h3><p>接口调用者，可能是和你进行协作的前端工程师、安卓BoyOrGirl，也有可能是任何的开发者，甚至可能是在你之后继续进行开发工作的同事。因此在他们调用时最好可以很快的进行上手。</p><p>依赖的安装，或者叫环境的配置永远是程序员所<strong>头疼和厌恶</strong>的问题，因此API的实现应该使用尽可能少的外部依赖。</p><h3 id="不要泄露内部实现细节"><a href="#不要泄露内部实现细节" class="headerlink" title="不要泄露内部实现细节"></a><strong>不要泄露内部实现细节</strong></h3><p>接口存在的意义，就是为了能够使项目的各个部分以模块化的方式进行协作和开发，接口的实现隐藏了一个模块的内部实现逻辑，而这些信息对于其他的模块来说是<strong>不必要的</strong>，首先暴露内部实现对于模块本身是不安全的，其次内部实现对于其他模块可能产生干扰。</p><p>因此接口的存在要整洁。不要有任何多余的冗余信息。</p><h3 id="良好的命名"><a href="#良好的命名" class="headerlink" title="良好的命名"></a><strong>良好的命名</strong></h3><p>命名是任何程序员都会遇到的问题，对于程序的变量，函数名等等都需要注意，这里对于接口的名称，参数名称等等进行约束。</p><ul><li>拼写准确<ul><li>写错字还挺丢人的</li></ul></li><li>时态准确<ul><li>正确的时态能给调用者很好的引导</li></ul></li><li>函数最好的动宾结构</li><li>属性最好是定语+名词<ul><li>定语可以很好的加深调用者对于参数的理解</li></ul></li><li>不要用生僻单词<ul><li>不要在不必要的地方秀英语</li></ul></li><li>不要自己创造缩写<ul><li>这方面的创造是不必要的</li></ul></li><li>便于调用者理解<ul><li>任何关于接口的设计都应该坚持这一点</li></ul></li></ul><h3 id="性能要好"><a href="#性能要好" class="headerlink" title="性能要好"></a><strong>性能要好</strong></h3><p>事实上这一点才应该是实现接口的程序员最上心的一点。一个接口的性能是很重要的，这直接体现了一个程序员的水平。代码的<strong>行数</strong>并不重要，重要的是接口的性能。当然可以使用各种手段来让你的代码性能变高，但是同时也要注意之前提到的<strong>依赖问题</strong>。</p><h3 id="接口的设计上应该注意的细节"><a href="#接口的设计上应该注意的细节" class="headerlink" title="接口的设计上应该注意的细节"></a><strong>接口的设计上应该注意的细节</strong></h3><ul><li>写注释</li><li>方法的出现要成对<ul><li>open-close add-remove</li></ul></li><li>一套API应该具有相同的名词规范</li><li>使用的意义相同的变量名称应该相同</li><li>不要给已经有了约定俗成的语义的状态码新的语义<ul><li>比如 401Unauthorized</li></ul></li><li>减少在API中的冗余信息<ul><li>比如path中仅出现一个ID时并不需要特殊命名。</li></ul></li><li>不要让一个接口实现多个功能</li></ul><h3 id="API和API，模块和模块之间的关系"><a href="#API和API，模块和模块之间的关系" class="headerlink" title="API和API，模块和模块之间的关系"></a><strong>API和API，模块和模块之间的关系</strong></h3><ul><li>任何语言都不允许循环调用（循环继承，循环引入）。在实现模块的时候也应该遵循同样的原则：<strong>不要让API和API，模块和模块之间的依赖关系变得复杂</strong>，应该有明确的单向依赖关系。当底层接口过于多调用过于繁琐时应该在两层之间加一个胶水层（工具函数层）。</li></ul><h3 id="一个API应该包含的内容"><a href="#一个API应该包含的内容" class="headerlink" title="一个API应该包含的内容"></a><strong>一个API应该包含的内容</strong></h3><p>以下内容基本都以文档的形式实现。</p><h4 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h4><pre><code>即使用者应该如何调用。使用何种方式进行调用。</code></pre><h4 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h4><pre><code>各个部分的参数应该以怎样的约定进行传入，传出的数据又以怎样的形式进行组织等等。</code></pre><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><pre><code>调用的条件。</code></pre><h2 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h2><p><a href="https://shiinaorez.github.io/2019/04/10/RESTful/" target="_blank" rel="noopener">RESTful API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计API前读一读&quot;&gt;&lt;a href=&quot;#设计API前读一读&quot; class=&quot;headerlink&quot; title=&quot;设计API前读一读&quot;&gt;&lt;/a&gt;设计API前读一读&lt;/h1&gt;&lt;h2 id=&quot;设计API应该达到的目标：&quot;&gt;&lt;a href=&quot;#设计API应该达到的目标
      
    
    </summary>
    
    
    
      <category term="软件体系结构" scheme="http://shiinaorez.github.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>login_required身份验证用装饰器for api [flask version]</title>
    <link href="http://shiinaorez.github.com/2018/08/18/login-required/"/>
    <id>http://shiinaorez.github.com/2018/08/18/login-required/</id>
    <published>2018-08-18T09:50:32.000Z</published>
    <updated>2019-04-08T15:39:45.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="涂api是一件莫名其妙就会有绊脚石的工作"><a href="#涂api是一件莫名其妙就会有绊脚石的工作" class="headerlink" title="涂api是一件莫名其妙就会有绊脚石的工作"></a>涂api是一件莫名其妙就会有绊脚石的工作</h2><p>之前涂api，每一个api都要传token（身份验证令牌），然后调用confirm方法比较等等。<br>这次涂api总得进步不是。。于是就要把身份验证抽离。<br>按照常规的做法，这次我要写一个<strong>decorator</strong>，叫做<strong>login_required</strong></p><p>对了这次博客讲解的<a href="https://github.com/Muxi-X/work.muxixyz_be_auth/blob/shiina/work_muxixyz_app/decorator.py" target="_blank" rel="noopener">代码</a></p><hr><h3 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h3><p>嘤嘤嘤…本来想抄抄<a href="https://github.com/Humbertzhang" target="_blank" rel="noopener">可可</a>的代码的…后来发现是用的aiohttp这个Python框架，虽然不会差很多，但是我看着就不想抄了..</p><p>于是 <del>自己动手丰衣足食</del> google了一下,找了半天知道这玩意儿还有专业名字：</p><p><strong>login_required</strong>  <del>我真的很想叫它别的名字，好听一点的</del></p><p>然后学啊学….跟着人家的经验走，最后居然花了一下午，弄完了</p><p>哦对准备工作：</p><ul><li>电脑</li><li>脑子</li><li>手</li></ul><hr><h2 id="Decorator-装饰器"><a href="#Decorator-装饰器" class="headerlink" title="@  Decorator  装饰器"></a><del>@</del>  <del>Decorator</del>  装饰器</h2><p>在Python里有乱七八糟的这个器那个器</p><p>朋友写了个博客，叫做<a href="https://darren2017.github.io/2018/04/10/python-%E4%B9%8B%E5%99%A8/#more" target="_blank" rel="noopener">Python之器</a> <del>虽然我也看不懂，但是可以看看给他增加以下浏览量</del></p><p>总之就是作用于函数，给函数加一层包装  <del>俄罗斯套娃笑死</del></p><hr><h2 id="from-import-as-各种包"><a href="#from-import-as-各种包" class="headerlink" title="from..import..as.. 各种包"></a><del>from..import..as..</del> 各种包</h2><p>这次写login_required()用到的包</p><ul><li>functools<ul><li>wraps  ：用来写装饰器的装饰器</li></ul></li><li>flask<ul><li>abort,request ：抛出错误处理以及请求包</li></ul></li><li>itsdangerous<ul><li>TimedJSONWebSignatureSerializer ：加密解密令牌</li></ul></li></ul><p>这个只是这个文件中用到的…. <del>莫名在别人博客被jwt圈粉，以后不想用Serializer了</del></p><hr><h2 id="开始写一个-浪费生命的-装饰器"><a href="#开始写一个-浪费生命的-装饰器" class="headerlink" title="开始写一个 浪费生命的 装饰器"></a>开始写一个 <del>浪费生命的</del> 装饰器</h2><p>我们开始吧：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(f)</span>:</span></span><br></pre></td></tr></table></figure></p><p><del>函数的</del> 第一行，你以后要用的装饰器的名字嘤嘤嘤，中间的参数<strong>f</strong>表<strong>function</strong>，是即将被我们进行 <del>俄罗斯套娃式处理</del> 修饰的函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@wraps(f)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorated_function</span><span class="params">(*args,**kwargs)</span>:</span></span><br></pre></td></tr></table></figure><p>接下来是二三行，首先我们用到了wraps，使用了@符号代表对接下来的函数<strong>decorated_function</strong>使用装饰器进行装饰，所以下面的函数名字是decorate的被动 <del>本人英文稀烂</del><br><strong>值得注意的是，装饰器使用语法后不加冒号</strong> <del>我知道你们不会注意的，但是我写错过quq</del></p><p>wraps的作用是帮助你写的函数成为装饰器</p><p><strong>*args,</strong> <strong>**kwargs </strong>代表各种各样的参数</p><p>接下来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="string">'token'</span> <span class="keyword">in</span> request.headers:</span><br><span class="line">    abort(<span class="number">401</span>)</span><br><span class="line">t=request.headers[<span class="string">'token'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">s=Serializer(current_app.config[<span class="string">'SECRET_KEY'</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    data=s.loads(t)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    abort(<span class="number">401</span>)</span><br><span class="line">uid=data.get(<span class="string">'confirm'</span>)</span><br><span class="line"><span class="keyword">return</span> f(uid,*args,**kwargs)</span><br></pre></td></tr></table></figure></p><p>非常抱歉我保持了缩进 <del>强迫症真的别管我</del></p><p>这里就是正文了，首先我们判断我们需要的<strong>token</strong>是否存在于<strong>request.headers</strong>中，如果不存在，说明接下来就没有必要操作了，直接<strong>abort(401)</strong></p><pre><code>abort(status_code)用于抛出错误，而401在状态码的意义中往往表示身份验证失败</code></pre><p>t是从headers[‘token’]字段中encode出来的，所以不需要再次encode <del>每次encode和decode多少次我都是人肉debug</del><br>s是我们解密用的秘钥，在这里我们要使用包来对config中的SECRET_KEY进行处理，为解密token做准备</p><p>然后是一个解密工作，为<strong>s.loads()</strong>如果解密失败，也直接抛出401给前端 <del>我测试的时候瞎写状态码写成了405hhhhh</del></p><p>解密完之后，<del>flask套路生成的</del> token变为了一个json数据段，我们取出名为<strong>confirm</strong>的数据，就是token携带的userID</p><p>最后值得注意的是，我们接受了一个函数作为参数，所以我们也要返回一个函数。这里函数别的都没有变，唯独多出个参数，目的是从装饰器的 “预操作”中取出我们<strong>真正需要</strong>的值。而预处理的内容，都写进了被wraps装饰的这个函数里。</p><p>最后：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> decorated_function</span><br></pre></td></tr></table></figure></p><p>我们在login_required(f)中传进来的参数，变成了被装饰后的函数<strong>decorated_function</strong>，我们直接返回就好了。</p><p>然后我们就</p><hr><h2 id="写完了-令人头秃的-装饰器"><a href="#写完了-令人头秃的-装饰器" class="headerlink" title="写完了 令人头秃的 装饰器"></a>写完了 <del>令人头秃的</del> 装饰器</h2><p>其实写好装饰器不是困难的全部，你要去学会怎么使用你自己写的装饰器，要改动你的api文件，还要写好单元测试去测试你的装饰器。这几件事情联系在一起就 <del>令人头秃</del> 比较麻烦。</p><hr><p><strong>我真的垃圾</strong></p><p>最后欢迎 <del>各位观众姥爷</del> 点个<a href="https://blog.csdn.net/Shiina_Orez" target="_blank" rel="noopener">关注</a>啥的<br>还有我的<a href="https://github.com/ShiinaOrez" target="_blank" rel="noopener">github地址</a><br>当然还有 <del>假装是自己搭建的</del> <a href="shiinaorez.github.io">小小博客</a></p><p><del>祝各位暴打产品经理</del><br> <del>祝各位福如东海，寿比南….</del><br> <del>祝各位考的全会蒙的全…….</del><br> <del>祝各位……</del></p><h2 id="DEBUG不用玄学小黄鸭！"><a href="#DEBUG不用玄学小黄鸭！" class="headerlink" title="DEBUG不用玄学小黄鸭！"></a>DEBUG不用玄学小黄鸭！</h2><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;涂api是一件莫名其妙就会有绊脚石的工作&quot;&gt;&lt;a href=&quot;#涂api是一件莫名其妙就会有绊脚石的工作&quot; class=&quot;headerlink&quot; title=&quot;涂api是一件莫名其妙就会有绊脚石的工作&quot;&gt;&lt;/a&gt;涂api是一件莫名其妙就会有绊脚石的工作&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
    
      <category term="python" scheme="http://shiinaorez.github.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Linux终端上的github基础教程</title>
    <link href="http://shiinaorez.github.com/2018/07/20/github/"/>
    <id>http://shiinaorez.github.com/2018/07/20/github/</id>
    <published>2018-07-20T05:40:09.000Z</published>
    <updated>2019-04-08T15:39:45.220Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎各位来到木犀团队后端组星计划Github部分"><a href="#欢迎各位来到木犀团队后端组星计划Github部分" class="headerlink" title="欢迎各位来到木犀团队后端组星计划Github部分"></a>欢迎各位来到木犀团队后端组星计划Github部分</h1><p>经过之前的学习，相信大家现在已经能够进入Linux系统了！<br>恭喜你们，现在有了一个比Windows好些的开发平台。<br>接下来我的这篇博客的目的是教你们使用开发者手中的利器–github.com</p><h2 id="什么是Github"><a href="#什么是Github" class="headerlink" title="什么是Github"></a>什么是Github</h2><p>简单而非学术的说：就是大家放代码的地方。<br>你可以放自己的练习代码。<br>也可以和别人一起开发。<br>当然别人的代码是可以公开的，而你的代码也可以是公开的。</p><p>这是一个开源网站，是属于开发人员的圣地–github</p><hr><h2 id="首先我们应该拥有一个账户！"><a href="#首先我们应该拥有一个账户！" class="headerlink" title="首先我们应该拥有一个账户！"></a>首先我们应该拥有一个账户！</h2><p>不要以为纯英文界面都会被墙！<br>github是使用国内的网络就可以访问的！<br>网址：<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a><br>或者百度github</p><p><img src="https://img-blog.csdn.net/20180719232322136?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>这里是首页，如果心细的话可以去看看首页的话都是什么意思www<br>我们点击右上角的Sign Up（注册</p><p><img src="https://img-blog.csdn.net/20180719232400451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>在下面填写个人信息，注意不能使用重复的用户名和邮箱。<br>这里要注意用户名使用英文的，以免带来不必要的麻烦。<br>密码设置要有一定的复杂度！<br>我们点击create an account</p><p><img src="https://img-blog.csdn.net/20180719232547131?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>第二步这里不要更改，直接点击continue</p><p><img src="https://img-blog.csdn.net/20180719232703768?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>第三步，这里是让你写一些问题的答案。<br>第一个问题是问你写代码的水平，如果你是小白的话就选第一个咯。<br>第二个问题是问你为什么注册，我们选择Project Management.<br>第三个问题是问你什么职业，显然是第一个。</p><p>然后你就创建成功了！<br><img src="https://img-blog.csdn.net/20180719232900810?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>这里有人发现不会验证邮箱对不对，但是千万不要大意，这个邮箱非常的重要的！！</p><hr><h2 id="下载安装git-core"><a href="#下载安装git-core" class="headerlink" title="下载安装git-core"></a>下载安装git-core</h2><p>Ubuntu系统的终端使用快捷键：Ctrl+Alt+T开启（T代表terminal）</p><p>然后会出现一个很酷酷的命令行界面：</p><p><img src="https://img-blog.csdn.net/20180720110641451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>你会发现命令行界面总有一串字符串：（以我自己的为例）</p><pre><code>shiina@shiina-Inspiron-7559:~$</code></pre><p>在@前面是你这个Linux下的用户，默认是你进入系统的用户。但是在某些状态下，我们需要使用超级用户权限。</p><p>我们使用</p><pre><code>sudo su</code></pre><p>这个命令，然后键入你的密码，就可以切换为超级管理员，此时你发现你的身份从shiina变成了root，root就是根用户，是超级用户（super user）</p><p>然后使用快捷键Ctrl+D退回，我们回到shiina这个用户的状态。</p><pre><code>虽然超级用户是一个很方便的东西，但是要注意不要乱用。超级用户时创建更改的所有文件都对于普通用户是只读状态。如果要修改要递归更改权限。谨慎使用。</code></pre><p>然后我们使用</p><pre><code>sudo apt-get updatesudo apt-get install git-core</code></pre><p>sudo就是使用super user的权限去do，可以使单独的命令具有超级用户权限。</p><p>apt-get暂时可以看作是手机上的应用商店。update是更新的意思，我们先更新一下自己系统中的”应用商店”。</p><p>install是安装的意思。git-core就是我们要安装的应用名称。怎么样，是不是简单明了？</p><p>安装成功之后，输入</p><pre><code>git --help</code></pre><p>来查看git这个”应用”的一些功能。</p><p><img src="https://img-blog.csdn.net/20180720112205988?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><hr><h2 id="把你之前注册的账户绑定到本地"><a href="#把你之前注册的账户绑定到本地" class="headerlink" title="把你之前注册的账户绑定到本地"></a>把你之前注册的账户绑定到本地</h2><p>使用命令：</p><pre><code>git config --global user.name &quot;your_name&quot;git config --global user.email &quot;your_email&quot;</code></pre><p>这两个命令的作用是告知git这个”应用”你的身份信息。</p><pre><code>ps:your_name和your_email务必要填写正确</code></pre><hr><h2 id="创建一个仓库叭w"><a href="#创建一个仓库叭w" class="headerlink" title="创建一个仓库叭w"></a>创建一个仓库叭w</h2><p>使用浏览器之前的github官网页面，右上角进入个人主页：</p><p><img src="https://img-blog.csdn.net/20180720123119568?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>然后点击到仓库（repository）的选项：</p><p><img src="https://img-blog.csdn.net/2018072012333550?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>有一个很瞩目的<strong>NEW</strong>按钮，我们点击：<br><img src="https://img-blog.csdn.net/20180720123541545?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>然后填写相关信息，包括仓库名称，描述信息等等</p><p><img src="https://img-blog.csdn.net/20180720124335381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>然后点击<strong>Create Repository </strong> </p><p>出现了！是一堆看不懂的东西！</p><p>这个页面代表你已经在github网站上创建了一个你自己的仓库。什么是仓库呢？就是集中放一类代码的地方。</p><p>我们现在有仓库了，但是仓库里空空如也，如果使用浏览器页面进行交互，不仅上传文件太慢，而且没有逼格。</p><hr><h2 id="使用终端进行文件上传！"><a href="#使用终端进行文件上传！" class="headerlink" title="使用终端进行文件上传！"></a>使用终端进行文件上传！</h2><p>wa怎么这么长啊这个博客（抱怨）<br>但是不要担心，这是最后一步了！</p><p>还记得刚才的那个全是看不懂语句的页面吗？不要关掉！我们来分析这个页面。<br>（当然关掉也无所谓啦～</p><p><img src="https://img-blog.csdn.net/20180720125237761?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoaWluYV9PcmV6/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>在被蓝色高亮的部分，有一个链接在框框里，这个框框里的链接就是你的仓库的URL（统一资源定位符）</p><pre><code>https://github.com/YOUR_NAME/REPOSITORY_NAME.git</code></pre><p>这么一种格式↑很好记的，记住的话就可以自然而然写出这个链接。</p><p>视线向下移动，有一句话叫做：</p><pre><code>...or create a new repository on the command line。。。或者用命令行创建一个新的仓库</code></pre><p>下面的命令挨个输入到命令行就好了…但是需要一些事先准备：</p><p>仓库在电脑本机上的出现形式是：文件夹<br>所以我们要用命令行创建新文件夹ww<br>和视图界面不同。。我们不需要 鼠标</p><pre><code>mkdir REPOSITORY_NAME//REPOSITORY_NAME是你仓库的名字cd REPOSITORY_NAME//进入文件夹</code></pre><p>然后就可以执行网页给你的命令了，但是我要更改一下顺序：</p><pre><code>git init//把这个文件夹变成本地的一个仓库git remote add origin https://github.com/YOUR_NAME/REPOSITORY_NAME.git//把本地仓库和github上的仓库对接起来</code></pre><p>此时，我们已经把本地仓库和远程仓库对接起来了w，接下来我们新建一个文件，然后上传！</p><pre><code>echo &quot;# REPOSITORY_NAME&quot; &gt;&gt; README.md//新建一个名为README.md的文件，其内容为：&quot;REPOSITORY_NAME&quot;git add README.md//将文件README.md 加入即将上传的空间git status//你可以看到这个文件的状态git commit -m &quot;my first commit&quot;//确认添加完了，我们提交即将上传的文件到缓冲区git push origin master//推上远程仓库，在这之后会让你输入用户名和密码，在这里的origin就是之前使用git remote语句链接到的远程仓库的链接地址。</code></pre><p>到现在你应该就完成了基本任务。但是git博大精深，所以暂时的放松之后。记得看我在后面写的其余知识点。</p><hr><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欢迎各位来到木犀团队后端组星计划Github部分&quot;&gt;&lt;a href=&quot;#欢迎各位来到木犀团队后端组星计划Github部分&quot; class=&quot;headerlink&quot; title=&quot;欢迎各位来到木犀团队后端组星计划Github部分&quot;&gt;&lt;/a&gt;欢迎各位来到木犀团队后端组星
      
    
    </summary>
    
    
    
      <category term="base" scheme="http://shiinaorez.github.com/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>kotlin学习笔记</title>
    <link href="http://shiinaorez.github.com/2018/07/12/kotlin-learning/"/>
    <id>http://shiinaorez.github.com/2018/07/12/kotlin-learning/</id>
    <published>2018-07-11T17:28:02.000Z</published>
    <updated>2019-04-08T15:39:45.224Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hin难受的kotlin学习之路"><a href="#hin难受的kotlin学习之路" class="headerlink" title="hin难受的kotlin学习之路"></a>hin难受的kotlin学习之路</h1><ul><li><p>首先是如何安装命令行编译情况，这样我们就可以欢快的nano了</p><ul><li>使用terminal，输入<ul><li>curl -s <a href="https://get.sdkman.io" target="_blank" rel="noopener">https://get.sdkman.io</a> | bash</li></ul></li><li><p>然后你就安装sdkman成功了，terminal上会说让你enjoy！</p><ul><li>接下来就是安装kotlin：sdk install kotlin</li><li>这个时候会有一个小问题，你的terminal说command not found:sdk，这时候不要慌，restart your terminal</li><li>：详情：<a href="https://stackoverflow.com/questions/45392965/sdk-command-is-not-found-is-coming-the-terminal" target="_blank" rel="noopener">解决方案-stackoverflow</a></li><li>这个过程非常的磨人。。我安装了7遍才成功，请确保自己科学上网了</li></ul><ul><li>接下来我们确保自己写好了一个hello,world，然后假设名字是hello.kt</li><li>在目录下，使用kotlinc命令生成.jar文件，使用java命令运行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kotlinc hello.kt -include-runtime -d hello.jar</span><br><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><hr><h4 id="kotlin-amp-go"><a href="#kotlin-amp-go" class="headerlink" title="kotlin&amp;go"></a>kotlin&amp;go</h4><ul><li>比如一样傻逼的变量声明：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> <span class="comment">//Go language</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a:<span class="built_in">Int</span> <span class="comment">//kotlin language</span></span><br></pre></td></tr></table></figure><ul><li>还有函数声明：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funName</span><span class="params">(arg <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;&#125; <span class="comment">//go language</span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">funName</span><span class="params">(arg:<span class="type">Int</span>)</span></span>:<span class="built_in">Int</span>&#123;&#125; <span class="comment">//kotlin language</span></span><br></pre></td></tr></table></figure><p>注意，kotlin的语法中是没有空类型的，空类型的返回值为Unit,但是很体贴的一点是，如果你的返回值是Unit那么可以省略。</p><p>在函数中有一个关键字叫做vararg，这个关键字的作用是可变长参数。作用有些类似于接收一个不定长的list。</p><p><strong>kotlin中很耀眼的一点就是函数可以简单声明：</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sum</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = a + b</span><br></pre></td></tr></table></figure><p>因此对于一些表达式函数我们可以很简单的去写。</p><hr><h4 id="变量定义："><a href="#变量定义：" class="headerlink" title="变量定义："></a>变量定义：</h4><p>变量定义分为两种：可变变量和不可变变量：</p><ul><li>可变变量：      var</li><li>不可变变量：  val</li></ul><p>val变量是不可变变量和常量有区别，不可变变量自始至终仅可被赋值一次。</p><hr><h4 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h4><p>和C、C++、Go的语法一致</p><hr><h4 id="基本数据类型："><a href="#基本数据类型：" class="headerlink" title="基本数据类型："></a>基本数据类型：</h4><p>kotlin中所谓的数据类型，其实是一个类。所有的变量都是实例。</p><p>有Byte，Short，Int，Float，Double，Char等等<br>长整型以L结尾，而十六进制是以0x开头 二进制以0b开头（不支持八进制！<br>单精度浮点数以f结尾，支持科学计数法</p><p>可以使用下划线对数字进行分割：123_456==123456</p><p>对于变量的比较：</p><ul><li>比较对象地址： ===</li><li>比较对象的值： ==</li></ul><p>类型强制转换：</p><p>每种数据类型都会有以下内置方法：</p><pre><code>toByte()toInt()..toChar()</code></pre><p>用作强制类型转换。</p><p><strong>此外，在kotlin中，char类型作为一个单独的数据类型存在，而不是数值类型。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hin难受的kotlin学习之路&quot;&gt;&lt;a href=&quot;#hin难受的kotlin学习之路&quot; class=&quot;headerlink&quot; title=&quot;hin难受的kotlin学习之路&quot;&gt;&lt;/a&gt;hin难受的kotlin学习之路&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;首先是如何
      
    
    </summary>
    
    
    
      <category term="kotlin" scheme="http://shiinaorez.github.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>树点分治--树上的重心</title>
    <link href="http://shiinaorez.github.com/2018/05/20/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    <id>http://shiinaorez.github.com/2018/05/20/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/</id>
    <published>2018-05-20T05:09:03.000Z</published>
    <updated>2019-04-08T15:39:45.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在面对一个无根树的时候，我们往往无从下手，便随便挑选一个节点作为根节点进行操作。<br>这是很不负责的一种行为，因为它可能导致很高的复杂度。比如对于一条链，你选择了两头的结点。。你很有可能面对爆栈的风险（NOIP2016D1T2 = =亲身经历）</p><p>那么，我们如果把一个很好看的树，比如一个满二叉树，把这个图看成无根图。<br>你会发现满二叉树的原本的根节点就是最好的选择：它恰巧在整个图的“中央”。</p><p>我们把这种最好的根节点的选择称为<strong>树的重心或者树的质点</strong>。</p><hr><h2 id="树的重心："><a href="#树的重心：" class="headerlink" title="树的重心："></a>树的重心：</h2><p>那么我们如何去求一棵无根树的重心呢？</p><p>当然是从重心的性质入手啦！</p><p>我们可以认识到，树的重心其实就是在整个图的“中央”，那么这个中央如何进行定义呢？为了保证深度最小（如果你把根节点放在树的重心上，那么它深度当然是最小的啦！）我们可以把深度最小近似看成是子树结点最少。（二者的关系的密切程度随着子树的划分逐渐密切）</p><p>即：去掉重心后，使得剩余子树的最多结点数最小。</p><hr><h2 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h2><p>我们需要保存一个子树最大结点数最小的情况，可以压缩为一个值min</p><pre><code>min代表我们找到的最小值，对应一个变量cog为树的重心的编号</code></pre><p>现在就是遍历所有的情况了，那么有人心态崩了：我岂不是要对所有的结点来一遍dfs？？</p><p>但其实不是这样的，我们只需要一次dfs，如果按照楼上的说法，我们解决了太多的重复子问题了。</p><p>我们任选一个结点作为本次寻找树的重心的根节点，然后进行一个dfs，我们意识到dfs可以遍历到所有的结点，也就是可以求到所有的划分子树的值。</p><p>怎么获取呢？<br>我们假设当前节点是now，父亲结点是from，now的儿子们是v[]<br>那么我们可以递归求得v[i]中包含的结点数，而now本身的返回值是sum=v[1]+v[2]+…+v[n]+1<br>此时我们遗漏了一个子树：那就是以from为根节点的子树！</p><p>而这个子树的节点数有点好求：N-sum</p><pre><code>N为总结点数，sum为所有儿子的节点数+1</code></pre><p>于是我们对比所有的值，取出最大值max</p><p>将max与min比较，更新cog</p><p>一遍遍历以后我们便取到了树的重心。</p><hr><h2 id="代码！（这次我真的不想写注释了）"><a href="#代码！（这次我真的不想写注释了）" class="headerlink" title="代码！（这次我真的不想写注释了）"></a>代码！（这次我真的不想写注释了）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to;</span><br><span class="line"><span class="keyword">int</span> next;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],sub_node[maxn],e,n,m,min=maxn,cog=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++e].next=head[u];</span><br><span class="line">edge[e].to=v;</span><br><span class="line">head[u]=e;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> from)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=head[now];i!=<span class="number">0</span>;i=edge[i].next)&#123;</span><br><span class="line"><span class="keyword">int</span> v=edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==from ) <span class="keyword">continue</span>;</span><br><span class="line">sum+=dfs(v,now);</span><br><span class="line"><span class="keyword">if</span>(sub_node[v]&gt;max) max=sub_node[v];</span><br><span class="line">&#125;</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">if</span>(max&lt;(n-sum))</span><br><span class="line">max=n-sum;</span><br><span class="line"><span class="keyword">if</span>(max&lt;min)&#123;</span><br><span class="line">min=max;</span><br><span class="line">cog=now;</span><br><span class="line">&#125;</span><br><span class="line">sub_node[now]=sum;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> s=dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"this tree 's center of gravity is :%d\n"</span>,cog);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>,sub_node[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><img src="http://r.photo.store.qq.com/psb?/V13Gxo2x1UzVE2/lFp7clZEpSW7uDjH9zBYFZ3owhvP2unOcmPoH*I8eM4!/r/dDMBAAAAAAAA" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;在面对一个无根树的时候，我们往往无从下手，便随便挑选一个节点作为根节点进行操作。&lt;br&gt;这是很不负责的一种行为，因为它可能导致很高的复杂度。
      
    
    </summary>
    
    
    
      <category term="algorithm" scheme="http://shiinaorez.github.com/tags/algorithm/"/>
    
  </entry>
  
</feed>
